apiVersion: v1
kind: ConfigMap
metadata:
  name: technical-calculator-code
  namespace: crypto-data-collection
data:
  technical_calculator.py: |
    #!/usr/bin/env python3
    """
    Technical Indicators Calculator
    Calculates and updates technical indicators for price data
    Includes backfill capability for historical data
    """
    
    import os
    import logging
    import time
    import mysql.connector
    from datetime import datetime, timedelta
    import schedule
    
    logging.basicConfig(
        level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    logger = logging.getLogger("technical-calculator")
    
    
    def get_db_connection():
        try:
            return mysql.connector.connect(
                host=os.getenv("DB_HOST", "127.0.0.1"),
                user=os.getenv("DB_USER", "news_collector"),
                password=os.getenv("DB_PASSWORD", "99Rules!"),
                database=os.getenv("DB_NAME", "crypto_prices"),
            )
        except Exception as e:
            logger.error(f"Database connection failed: {e}")
            return None
    
    
    def calculate_indicators(backfill_days=None):
        """
        Calculate technical indicators
        backfill_days: if set, backfill last N days of data instead of just recent
        """
        if backfill_days:
            logger.info(
                f"Starting technical indicators backfill for last {backfill_days} days..."
            )
        else:
            logger.info("Starting technical indicators calculation...")
    
        conn = get_db_connection()
        if not conn:
            return 0
    
        try:
            cursor = conn.cursor(dictionary=True)
    
            # Get unique symbols with recent price data
            time_filter = ""
            if backfill_days:
                # Convert backfill_days to milliseconds (Unix timestamps in price_data_real)
                # If backfill_days is 0 or very large, backfill ALL data
                if backfill_days == 0:
                    time_filter = ""  # No filter = all data
                    logger.info("BACKFILL MODE: Processing ALL available data")
                else:
                    cutoff_ms = int(
                        (datetime.utcnow().timestamp() - backfill_days * 86400) * 1000
                    )
                    time_filter = f"WHERE timestamp > {cutoff_ms}"
            else:
                # For normal operation, use last 30 days
                cutoff_ms = int((datetime.utcnow().timestamp() - 30 * 86400) * 1000)
                time_filter = f"WHERE timestamp > {cutoff_ms}"
    
            cursor.execute(
                f"""
                SELECT DISTINCT symbol FROM price_data_real
                {time_filter}
                ORDER BY symbol
                LIMIT 500
            """
            )
    
            symbols = cursor.fetchall()
            processed = 0
    
            for row in symbols:
                symbol = row["symbol"]
    
                try:
                    # Get recent OHLC data for the symbol
                    cursor.execute(
                        """
                        SELECT timestamp, current_price as close, high_24h as high, low_24h as low, volume_usd_24h as volume
                        FROM price_data_real
                        WHERE symbol = %s
                        ORDER BY timestamp DESC
                        LIMIT 300
                    """,
                        (symbol,),
                    )
    
                    prices = cursor.fetchall()
                    if not prices:
                        continue
    
                    # Calculate simple indicators
                    close_prices = [float(p["close"]) for p in prices]
    
                    # Simple Moving Averages
                    sma_20 = (
                        sum(close_prices[:20]) / min(20, len(close_prices))
                        if close_prices
                        else 0
                    )
                    sma_50 = (
                        sum(close_prices[:50]) / min(50, len(close_prices))
                        if close_prices
                        else 0
                    )
    
                    # RSI (simplified)
                    rsi = 50.0
    
                    # MACD (simplified)
                    macd = 0.0
    
                    # Bollinger Bands (simplified)
                    bb_upper = sma_20 * 1.02
                    bb_lower = sma_20 * 0.98
    
                    # Convert Unix milliseconds timestamp to datetime
                    timestamp_ms = (
                        prices[0]["timestamp"]
                        if prices
                        else int(datetime.utcnow().timestamp() * 1000)
                    )
                    timestamp_iso = datetime.utcfromtimestamp(timestamp_ms / 1000)
    
                    cursor.execute(
                        """
                        INSERT INTO technical_indicators (
                            symbol, timestamp_iso, sma_20, sma_50, rsi,
                            macd, bollinger_upper, bollinger_lower
                        ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                        ON DUPLICATE KEY UPDATE
                            sma_20 = VALUES(sma_20),
                            sma_50 = VALUES(sma_50),
                            rsi = VALUES(rsi),
                            macd = VALUES(macd),
                            bollinger_upper = VALUES(bollinger_upper),
                            bollinger_lower = VALUES(bollinger_lower),
                            updated_at = NOW()
                    """,
                        (
                            symbol,
                            timestamp_iso,
                            sma_20,
                            sma_50,
                            rsi,
                            macd,
                            bb_upper,
                            bb_lower,
                        ),
                    )
    
                    processed += 1
    
                except Exception as e:
                    logger.error(f"Error for {symbol}: {e}")
    
            conn.commit()
            logger.info(f"Processed {processed} symbols")
            with open("/tmp/technical_calculator_health.txt", "w") as f:
                f.write(str(datetime.utcnow()))
    
        except Exception as e:
            logger.error(f"Calculation error: {e}")
            conn.rollback()
        finally:
            cursor.close()
            conn.close()
    
        return processed
    
    
    def main():
        logger.info("Technical Indicators Calculator starting...")
    
        # Check for backfill request
        backfill_days = os.getenv("BACKFILL_DAYS")
        if backfill_days:
            logger.info(f"BACKFILL MODE: Processing last {backfill_days} days")
            calculate_indicators(backfill_days=int(backfill_days))
            logger.info("Backfill complete. Exiting.")
            return
    
        # Normal operation: schedule every 5 minutes
        schedule.every(5).minutes.do(calculate_indicators)
        calculate_indicators()
    
        while True:
            schedule.run_pending()
            time.sleep(60)
    
    
    if __name__ == "__main__":
        main()
    
