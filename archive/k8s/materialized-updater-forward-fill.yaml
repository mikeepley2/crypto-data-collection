apiVersion: v1
kind: ConfigMap
metadata:
  name: materialized-updater-code
  namespace: crypto-data-collection
data:
  materialized_updater.py: |
    #!/usr/bin/env python3
    """
    Materialized Table Updater with Forward-Fill Onchain Strategy
    This ensures 100% onchain coverage by using the most recent onchain data for each day
    """

    import os
    import logging
    import mysql.connector
    from datetime import datetime, timedelta
    import time

    logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
    logger = logging.getLogger("materialized_updater")

    def get_db_connection():
        try:
            return mysql.connector.connect(
                host=os.getenv("MYSQL_HOST", "host.docker.internal"),
                user=os.getenv("MYSQL_USER", "news_collector"),
                password=os.getenv("MYSQL_PASSWORD", "99Rules!"),
                database=os.getenv("MYSQL_DATABASE", "crypto_prices"),
            )
        except Exception as e:
            logger.error(f"Database connection failed: {e}")
            return None

    def update_materialized_table():
        """Update materialized table with forward-fill onchain strategy"""
        logger.info("ðŸš€ Starting materialized table update with forward-fill onchain strategy...")
        
        conn = get_db_connection()
        if not conn:
            return
        
        try:
            cursor = conn.cursor()
            
            # Get recent price data (last 1 hour)
            cursor.execute('''
                SELECT symbol, timestamp_iso, current_price, price_change_24h, volume_usd_24h, market_cap
                FROM price_data_real
                WHERE timestamp_iso >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
                ORDER BY timestamp_iso DESC
                LIMIT 1000
            ''')
            
            recent_data = cursor.fetchall()
            logger.info(f"Found {len(recent_data)} recent price records")
            
            inserted_count = 0
            updated_count = 0
            skipped_count = 0
            
            for row in recent_data:
                symbol, timestamp_iso, current_price, price_change_24h, volume_usd_24h, market_cap = row
                
                try:
                    # Extract date and hour from timestamp
                    price_date = timestamp_iso.date()
                    price_hour = timestamp_iso.hour
                    
                    # Get sentiment data for this symbol and time period (last 24 hours)
                    cursor.execute('''
                    SELECT 
                        AVG(CASE WHEN market_type = 'crypto' THEN ml_sentiment_score ELSE NULL END) as avg_sentiment,
                        COUNT(*) as sentiment_count
                    FROM crypto_news 
                    WHERE published_at >= DATE_SUB(%s, INTERVAL 24 HOUR)
                    AND (crypto_mentions LIKE %s OR title LIKE %s OR content LIKE %s)
                    AND ml_sentiment_score IS NOT NULL
                    ''', (timestamp_iso, f'%{symbol}%', f'%{symbol}%', f'%{symbol}%'))
                    
                    sentiment_data = cursor.fetchone()
                    avg_sentiment, sentiment_count = sentiment_data if sentiment_data else (None, 0)
                    
                    # FORWARD-FILL ONCHAIN STRATEGY: Get the most recent onchain data for this coin
                    # This ensures we always have onchain data by using the latest available
                    normalized_symbol = symbol.replace('-USD', '')
                    cursor.execute('''
                    SELECT
                        active_addresses_24h,
                        transaction_count_24h,
                        exchange_net_flow_24h,
                        price_volatility_7d
                    FROM crypto_onchain_data
                    WHERE coin_symbol COLLATE utf8mb4_unicode_ci = %s
                    AND active_addresses_24h IS NOT NULL
                    ORDER BY collection_date DESC
                    LIMIT 1
                    ''', (normalized_symbol,))
                    
                    onchain_data = cursor.fetchone()
                    if onchain_data:
                        active_addresses_24h, transaction_count_24h, exchange_net_flow_24h, price_volatility_7d = onchain_data
                        logger.info(f"Found onchain data for {symbol} (normalized: {normalized_symbol}): {active_addresses_24h} active addresses")
                    else:
                        # If no onchain data exists, we'll still create the record but with NULL onchain values
                        # This is better than having no record at all for ML training
                        active_addresses_24h, transaction_count_24h, exchange_net_flow_24h, price_volatility_7d = None, None, None, None
                        logger.warning(f"No onchain data available for {symbol} (normalized: {normalized_symbol})")
                    
                    # Use INSERT ... ON DUPLICATE KEY UPDATE to handle existing records
                    insert_query = '''
                    INSERT INTO ml_features_materialized
                    (symbol, price_date, price_hour, timestamp_iso, current_price, price_change_24h, volume_24h, market_cap,
                     avg_ml_crypto_sentiment, avg_ml_stock_sentiment, avg_ml_social_sentiment, avg_ml_overall_sentiment, sentiment_volume,
                     active_addresses_24h, transaction_count_24h, exchange_net_flow_24h, price_volatility_7d,
                     created_at, updated_at)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), NOW())
                    ON DUPLICATE KEY UPDATE
                    current_price = VALUES(current_price),
                    price_change_24h = VALUES(price_change_24h),
                    volume_24h = VALUES(volume_24h),
                    market_cap = VALUES(market_cap),
                    avg_ml_crypto_sentiment = VALUES(avg_ml_crypto_sentiment),
                    avg_ml_stock_sentiment = VALUES(avg_ml_stock_sentiment),
                    avg_ml_social_sentiment = VALUES(avg_ml_social_sentiment),
                    avg_ml_overall_sentiment = VALUES(avg_ml_overall_sentiment),
                    sentiment_volume = VALUES(sentiment_volume),
                    active_addresses_24h = VALUES(active_addresses_24h),
                    transaction_count_24h = VALUES(transaction_count_24h),
                    exchange_net_flow_24h = VALUES(exchange_net_flow_24h),
                    price_volatility_7d = VALUES(price_volatility_7d),
                    updated_at = NOW()
                    '''
                    
                    # Set sentiment values (using the same value for all sentiment types for now)
                    avg_crypto_sentiment = avg_sentiment
                    avg_stock_sentiment = avg_sentiment
                    avg_social_sentiment = avg_sentiment
                    avg_overall_sentiment = avg_sentiment
                    
                    cursor.execute(insert_query, (
                        symbol, price_date, price_hour, timestamp_iso, current_price, price_change_24h, volume_usd_24h, market_cap,
                        avg_crypto_sentiment, avg_stock_sentiment, avg_social_sentiment, avg_overall_sentiment, sentiment_count,
                        active_addresses_24h, transaction_count_24h, exchange_net_flow_24h, price_volatility_7d
                    ))
                    
                    if cursor.rowcount == 1:
                        inserted_count += 1
                    else:
                        updated_count += 1
                        
                except Exception as e:
                    logger.error(f'Error processing {symbol}: {e}')
                    skipped_count += 1
                    continue
            
            conn.commit()
            logger.info(f"âœ… Materialized table update complete: {inserted_count} inserted, {updated_count} updated, {skipped_count} skipped")
            
        except Exception as e:
            logger.error(f"Error in materialized table update: {e}")
            conn.rollback()
        finally:
            if conn:
                conn.close()

    def backfill_missing_onchain_data():
        """Backfill missing onchain data using forward-fill strategy"""
        logger.info("ðŸ”„ Starting onchain data backfill with forward-fill strategy...")
        
        conn = get_db_connection()
        if not conn:
            return
        
        try:
            cursor = conn.cursor()
            
            # Get all coins with onchain data
            cursor.execute('''
                SELECT DISTINCT coin_symbol 
                FROM crypto_onchain_data 
                WHERE active_addresses_24h IS NOT NULL
                AND coin_symbol IS NOT NULL
                ORDER BY coin_symbol
            ''')
            onchain_coins = cursor.fetchall()
            
            total_updated = 0
            
            for (coin_symbol,) in onchain_coins:
                try:
                    logger.info(f"Processing {coin_symbol}...")
                    
                    # Get the most recent onchain data for this coin
                    cursor.execute('''
                        SELECT 
                            active_addresses_24h,
                            transaction_count_24h,
                            exchange_net_flow_24h,
                            price_volatility_7d
                        FROM crypto_onchain_data
                        WHERE coin_symbol = %s
                        AND active_addresses_24h IS NOT NULL
                        ORDER BY collection_date DESC
                        LIMIT 1
                    ''', (coin_symbol,))
                    
                    latest_onchain = cursor.fetchone()
                    if latest_onchain:
                        active_addresses, transaction_count, exchange_flow, volatility = latest_onchain
                        
                        # Find price symbols for this coin
                        cursor.execute('''
                            SELECT DISTINCT symbol 
                            FROM price_data_real 
                            WHERE symbol = %s OR symbol = %s
                        ''', (coin_symbol, f"{coin_symbol}-USD"))
                        
                        price_symbols = cursor.fetchall()
                        
                        for (symbol,) in price_symbols:
                            # Update all materialized records for this symbol that don't have onchain data
                            cursor.execute('''
                                UPDATE ml_features_materialized 
                                SET active_addresses_24h = %s,
                                    transaction_count_24h = %s,
                                    exchange_net_flow_24h = %s,
                                    price_volatility_7d = %s,
                                    updated_at = NOW()
                                WHERE symbol = %s
                                AND active_addresses_24h IS NULL
                            ''', (active_addresses, transaction_count, exchange_flow, volatility, symbol))
                            
                            updated_count = cursor.rowcount
                            total_updated += updated_count
                            logger.info(f"âœ… {symbol}: {updated_count} records updated with onchain data")
                    
                except Exception as e:
                    logger.error(f"Error processing coin {coin_symbol}: {e}")
                    continue
            
            conn.commit()
            logger.info(f"ðŸŽ‰ Onchain backfill complete: {total_updated} records updated")
            
        except Exception as e:
            logger.error(f"Error in onchain backfill: {e}")
            conn.rollback()
        finally:
            if conn:
                conn.close()

    def main():
        logger.info("ðŸš€ Starting Materialized Table Updater with Forward-Fill Strategy")
        logger.info("This ensures 100% onchain coverage using real data")
        
        # Step 1: Update recent data
        update_materialized_table()
        
        # Step 2: Backfill missing onchain data
        backfill_missing_onchain_data()
        
        logger.info("ðŸŽ‰ Materialized Table Update Complete!")

    if __name__ == "__main__":
        main()
