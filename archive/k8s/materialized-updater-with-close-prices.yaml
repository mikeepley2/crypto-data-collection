apiVersion: v1
kind: ConfigMap
metadata:
  name: materialized-updater-code
  namespace: crypto-data-collection
data:
  materialized_updater.py: |
    #!/usr/bin/env python3
    """
    Comprehensive Materialized Table Updater with Close Price Logic
    Updates ALL data sources: price, sentiment, onchain, technical, macro
    Implements proper end-of-day close price logic
    """

    import os
    import logging
    import time
    import mysql.connector
    from mysql.connector import pooling
    from datetime import datetime, timedelta
    import threading
    import schedule

    logging.basicConfig(
        level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    logger = logging.getLogger("materialized-updater")

    # Global connection pool
    db_pool = None

    def init_connection_pool():
        """Initialize database connection pool"""
        global db_pool
        try:
            db_pool = pooling.MySQLConnectionPool(
                pool_name="materialized_pool",
                pool_size=3,
                pool_reset_session=True,
                host=os.getenv("DB_HOST", "127.0.0.1"),
                user=os.getenv("DB_USER", "news_collector"),
                password=os.getenv("DB_PASSWORD", "99Rules!"),
                database=os.getenv("DB_NAME", "crypto_prices"),
                autocommit=False,
                charset="utf8mb4"
            )
            logger.info("‚úÖ Database connection pool initialized")
            return True
        except Exception as e:
            logger.error(f"‚ùå Database pool initialization failed: {e}")
            return False

    def get_db_connection():
        """Get connection from pool"""
        try:
            return db_pool.get_connection()
        except Exception as e:
            logger.error(f"Failed to get connection from pool: {e}")
            return None

    def get_latest_macro_data():
        """Get latest macro data from macro_indicators table"""
        conn = get_db_connection()
        if not conn:
            return {}
        
        try:
            cursor = conn.cursor()
            
            # Get latest macro data
            cursor.execute("""
                SELECT indicator_name, value, indicator_date
                FROM macro_indicators 
                WHERE indicator_date >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
                ORDER BY indicator_date DESC
            """)
            
            macro_data = cursor.fetchall()
            if not macro_data:
                return {}
            
            # Map macro indicators to materialized table columns
            macro_mapping = {
                'VIX': 'vix',
                'SPX': 'spx', 
                'DXY': 'dxy',
                'TREASURY_10Y': 'treasury_10y',
                'UNEMPLOYMENT': 'unemployment_rate',
                'INFLATION': 'inflation_rate',
                'GOLD': 'gold_price',
                'OIL': 'oil_price'
            }
            
            # Get latest values for each indicator
            latest_values = {}
            for indicator_name, value, indicator_date in macro_data:
                if indicator_name in macro_mapping:
                    column_name = macro_mapping[indicator_name]
                    if column_name not in latest_values or indicator_date > latest_values[column_name][1]:
                        latest_values[column_name] = (value, indicator_date)
            
            return latest_values
            
        except Exception as e:
            logger.error(f"Error getting macro data: {e}")
            return {}
        finally:
            if conn:
                conn.close()

    def get_daily_close_price(symbol, price_date):
        """Get the close price for a symbol on a specific date"""
        conn = get_db_connection()
        if not conn:
            return None
        
        try:
            cursor = conn.cursor()
            
            # Get the last price of the day for this symbol
            cursor.execute("""
                SELECT current_price, timestamp_iso
                FROM price_data_real 
                WHERE symbol = %s 
                AND DATE(timestamp_iso) = %s
                ORDER BY timestamp_iso DESC
                LIMIT 1
            """, (symbol, price_date))
            
            result = cursor.fetchone()
            if result:
                close_price, close_timestamp = result
                logger.debug(f"Close price for {symbol} on {price_date}: ${close_price} at {close_timestamp}")
                return close_price
            
            return None
            
        except Exception as e:
            logger.error(f"Error getting close price for {symbol} on {price_date}: {e}")
            return None
        finally:
            if conn:
                conn.close()

    def update_materialized_table():
        """Update materialized table with comprehensive data including close prices"""
        logger.info("üöÄ Starting comprehensive materialized table update with close prices...")
        
        conn = get_db_connection()
        if not conn:
            return
        
        try:
            cursor = conn.cursor()
            
            # Get latest macro data
            macro_data = get_latest_macro_data()
            
            # Get all price data
            cursor.execute("""
                SELECT symbol, timestamp_iso, current_price, price_change_24h, volume_usd_24h, market_cap
                FROM price_data_real 
                WHERE timestamp_iso >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
                ORDER BY symbol, timestamp_iso
            """)
            
            price_data = cursor.fetchall()
            logger.info(f"Processing {len(price_data)} price records")
            
            inserted_count = 0
            updated_count = 0
            skipped_count = 0
            
            for symbol, timestamp_iso, current_price, price_change_24h, volume_usd_24h, market_cap in price_data:
                try:
                    # Extract date and hour from timestamp
                    price_date = timestamp_iso.date()
                    price_hour = timestamp_iso.hour
                    
                    # Get close price for this date (last price of the day)
                    close_price = get_daily_close_price(symbol, price_date)
                    if close_price is None:
                        close_price = current_price  # Fallback to current price
                    
                    # Get sentiment data with time-based decay
                    cursor.execute('''
                        SELECT 
                            AVG(CASE 
                                WHEN published_at >= DATE_SUB(%s, INTERVAL 1 HOUR) THEN ml_sentiment_score * 1.0
                                WHEN published_at >= DATE_SUB(%s, INTERVAL 6 HOUR) THEN ml_sentiment_score * 0.8
                                WHEN published_at >= DATE_SUB(%s, INTERVAL 24 HOUR) THEN ml_sentiment_score * 0.6
                                ELSE ml_sentiment_score * 0.3
                            END) as weighted_sentiment,
                            COUNT(*) as sentiment_count,
                            AVG(ml_sentiment_score) as raw_sentiment
                        FROM crypto_news
                        WHERE published_at >= DATE_SUB(%s, INTERVAL 24 HOUR)
                        AND published_at <= %s
                        AND ml_sentiment_score IS NOT NULL
                    ''', (timestamp_iso, timestamp_iso, timestamp_iso, timestamp_iso, timestamp_iso))
                    
                    sentiment_data = cursor.fetchone()
                    if sentiment_data:
                        avg_sentiment, sentiment_count, raw_sentiment = sentiment_data
                        if avg_sentiment is None and raw_sentiment is not None:
                            avg_sentiment = raw_sentiment
                    else:
                        avg_sentiment, sentiment_count = None, 0
                    
                    # Get onchain data with forward-fill strategy
                    normalized_symbol = symbol.replace('-USD', '')
                    onchain_data = None
                    
                    cursor.execute('''
                        SELECT active_addresses_24h, transaction_count_24h, exchange_net_flow_24h, price_volatility_7d
                        FROM crypto_onchain_data 
                        WHERE coin_symbol = %s 
                        AND collection_date >= DATE_SUB(%s, INTERVAL 1 DAY)
                        AND collection_date <= %s
                        ORDER BY collection_date DESC
                        LIMIT 1
                    ''', (normalized_symbol, timestamp_iso, timestamp_iso))
                    
                    onchain_data = cursor.fetchone()
                    if onchain_data:
                        active_addresses_24h, transaction_count_24h, exchange_net_flow_24h, price_volatility_7d = onchain_data
                    else:
                        active_addresses_24h = transaction_count_24h = exchange_net_flow_24h = price_volatility_7d = None
                    
                    # Get technical indicators from price_data_real
                    cursor.execute('''
                        SELECT sma_20, rsi_14, macd, macd_signal, macd_histogram, bb_upper, bb_middle, bb_lower
                        FROM price_data_real 
                        WHERE symbol = %s AND timestamp_iso = %s
                    ''', (symbol, timestamp_iso))
                    
                    tech_data = cursor.fetchone()
                    if tech_data:
                        sma_20, rsi_14, macd_line, macd_signal, macd_histogram, bb_upper, bb_middle, bb_lower = tech_data
                    else:
                        sma_20 = rsi_14 = macd_line = macd_signal = macd_histogram = bb_upper = bb_middle = bb_lower = None
                    
                    # Use INSERT ... ON DUPLICATE KEY UPDATE with ALL columns including close prices
                    insert_query = '''
                    INSERT INTO ml_features_materialized
                    (symbol, price_date, price_hour, timestamp_iso, current_price, price_change_24h, volume_24h, market_cap,
                     avg_ml_overall_sentiment, sentiment_volume,
                     active_addresses_24h, transaction_count_24h, exchange_net_flow_24h, price_volatility_7d,
                     sma_20, rsi_14, macd_line, macd_signal, macd_histogram, bb_upper, bb_middle, bb_lower,
                     vix, spx, dxy, treasury_10y, unemployment_rate, inflation_rate, gold_price, oil_price,
                     close_price, close,
                     created_at, updated_at)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, NOW(), NOW())
                    ON DUPLICATE KEY UPDATE
                    current_price = VALUES(current_price),
                    price_change_24h = VALUES(price_change_24h),
                    volume_24h = VALUES(volume_24h),
                    market_cap = VALUES(market_cap),
                    avg_ml_overall_sentiment = VALUES(avg_ml_overall_sentiment),
                    sentiment_volume = VALUES(sentiment_volume),
                    active_addresses_24h = VALUES(active_addresses_24h),
                    transaction_count_24h = VALUES(transaction_count_24h),
                    exchange_net_flow_24h = VALUES(exchange_net_flow_24h),
                    price_volatility_7d = VALUES(price_volatility_7d),
                    sma_20 = VALUES(sma_20),
                    rsi_14 = VALUES(rsi_14),
                    macd_line = VALUES(macd_line),
                    macd_signal = VALUES(macd_signal),
                    macd_histogram = VALUES(macd_histogram),
                    bb_upper = VALUES(bb_upper),
                    bb_middle = VALUES(bb_middle),
                    bb_lower = VALUES(bb_lower),
                    vix = VALUES(vix),
                    spx = VALUES(spx),
                    dxy = VALUES(dxy),
                    treasury_10y = VALUES(treasury_10y),
                    unemployment_rate = VALUES(unemployment_rate),
                    inflation_rate = VALUES(inflation_rate),
                    gold_price = VALUES(gold_price),
                    oil_price = VALUES(oil_price),
                    close_price = VALUES(close_price),
                    close = VALUES(close),
                    updated_at = NOW()
                    '''
                    
                    # Prepare macro data values
                    vix_val = macro_data.get('vix', (None, None))[0] if 'vix' in macro_data else None
                    spx_val = macro_data.get('spx', (None, None))[0] if 'spx' in macro_data else None
                    dxy_val = macro_data.get('dxy', (None, None))[0] if 'dxy' in macro_data else None
                    treasury_val = macro_data.get('treasury_10y', (None, None))[0] if 'treasury_10y' in macro_data else None
                    unemployment_val = macro_data.get('unemployment_rate', (None, None))[0] if 'unemployment_rate' in macro_data else None
                    inflation_val = macro_data.get('inflation_rate', (None, None))[0] if 'inflation_rate' in macro_data else None
                    gold_val = macro_data.get('gold_price', (None, None))[0] if 'gold_price' in macro_data else None
                    oil_val = macro_data.get('oil_price', (None, None))[0] if 'oil_price' in macro_data else None
                    
                    cursor.execute(insert_query, (
                        symbol, price_date, price_hour, timestamp_iso, current_price, price_change_24h, volume_usd_24h, market_cap,
                        avg_sentiment, sentiment_count,
                        active_addresses_24h, transaction_count_24h, exchange_net_flow_24h, price_volatility_7d,
                        sma_20, rsi_14, macd_line, macd_signal, macd_histogram, bb_upper, bb_middle, bb_lower,
                        vix_val, spx_val, dxy_val, treasury_val, unemployment_val, inflation_val, gold_val, oil_val,
                        close_price, close_price  # Both close_price and close get the same value
                    ))
                    
                    if cursor.rowcount > 0:
                        if cursor.rowcount == 1:
                            inserted_count += 1
                        else:
                            updated_count += 1
                    else:
                        skipped_count += 1
                        
                except Exception as e:
                    logger.error(f'Error processing {symbol} at {timestamp_iso}: {e}')
                    skipped_count += 1
            
            conn.commit()
            logger.info(f"‚úÖ Comprehensive materialized table update complete: {inserted_count} inserted, {updated_count} updated, {skipped_count} skipped")
            
            # Write health check file
            with open("/tmp/materialized_updater_health.txt", "w") as f:
                f.write(str(datetime.utcnow()))
                
        except Exception as e:
            logger.error(f"Update error: {e}")
            conn.rollback()
        finally:
            if conn:
                conn.close()  # Return connection to pool

    def continuous_sentiment_backfill():
        """Continuous sentiment backfill for missing records"""
        logger.info("üîÑ Starting continuous sentiment backfill...")
        
        conn = get_db_connection()
        if not conn:
            return
        
        try:
            cursor = conn.cursor()
            
            # Get records missing sentiment data
            cursor.execute("""
                SELECT symbol, timestamp_iso 
                FROM ml_features_materialized 
                WHERE avg_ml_overall_sentiment IS NULL 
                AND timestamp_iso >= DATE_SUB(NOW(), INTERVAL 7 DAY)
                ORDER BY timestamp_iso DESC
                LIMIT 1000
            """)
            
            missing_records = cursor.fetchall()
            logger.info(f"Found {len(missing_records)} records missing sentiment data")
            
            updated_count = 0
            for symbol, timestamp_iso in missing_records:
                try:
                    # Time-based sentiment lookup with decay weights
                    cursor.execute('''
                        SELECT 
                            AVG(CASE 
                                WHEN published_at >= DATE_SUB(%s, INTERVAL 1 HOUR) THEN ml_sentiment_score * 1.0
                                WHEN published_at >= DATE_SUB(%s, INTERVAL 6 HOUR) THEN ml_sentiment_score * 0.8
                                WHEN published_at >= DATE_SUB(%s, INTERVAL 24 HOUR) THEN ml_sentiment_score * 0.6
                                ELSE ml_sentiment_score * 0.3
                            END) as weighted_sentiment,
                            COUNT(*) as sentiment_count,
                            AVG(ml_sentiment_score) as raw_sentiment
                        FROM crypto_news
                        WHERE published_at >= DATE_SUB(%s, INTERVAL 24 HOUR)
                        AND published_at <= %s
                        AND ml_sentiment_score IS NOT NULL
                    ''', (timestamp_iso, timestamp_iso, timestamp_iso, timestamp_iso, timestamp_iso))
                    
                    sentiment_data = cursor.fetchone()
                    if sentiment_data and sentiment_data[0] is not None:
                        weighted_sentiment, sentiment_count, raw_sentiment = sentiment_data
                        final_sentiment = weighted_sentiment if weighted_sentiment is not None else raw_sentiment
                        
                        cursor.execute('''
                            UPDATE ml_features_materialized
                            SET avg_ml_overall_sentiment = %s,
                                sentiment_volume = %s,
                                updated_at = NOW()
                            WHERE symbol = %s AND timestamp_iso = %s
                        ''', (final_sentiment, sentiment_count, symbol, timestamp_iso))
                        
                        if cursor.rowcount > 0:
                            updated_count += 1
                            
                except Exception as e:
                    logger.error(f"Error updating sentiment for {symbol} at {timestamp_iso}: {e}")
                    continue
            
            conn.commit()
            logger.info(f"‚úÖ Sentiment backfill complete: {updated_count} records updated")
            
        except Exception as e:
            logger.error(f"Sentiment backfill error: {e}")
            conn.rollback()
        finally:
            if conn:
                conn.close()

    def update_close_prices_for_completed_days():
        """Update close prices for all completed days"""
        logger.info("üîÑ Starting close price update for completed days...")
        
        conn = get_db_connection()
        if not conn:
            return
        
        try:
            cursor = conn.cursor()
            
            # Get all unique symbols and dates that need close price updates
            cursor.execute("""
                SELECT DISTINCT symbol, price_date
                FROM ml_features_materialized 
                WHERE close_price IS NULL 
                AND price_date < CURDATE()
                ORDER BY symbol, price_date
                LIMIT 1000
            """)
            
            missing_close_prices = cursor.fetchall()
            logger.info(f"Found {len(missing_close_prices)} symbol-date combinations missing close prices")
            
            updated_count = 0
            for symbol, price_date in missing_close_prices:
                try:
                    # Get the close price for this symbol and date
                    close_price = get_daily_close_price(symbol, price_date)
                    if close_price is not None:
                        cursor.execute('''
                            UPDATE ml_features_materialized
                            SET close_price = %s,
                                close = %s,
                                updated_at = NOW()
                            WHERE symbol = %s AND price_date = %s
                        ''', (close_price, close_price, symbol, price_date))
                        
                        if cursor.rowcount > 0:
                            updated_count += 1
                            
                except Exception as e:
                    logger.error(f"Error updating close price for {symbol} on {price_date}: {e}")
                    continue
            
            conn.commit()
            logger.info(f"‚úÖ Close price update complete: {updated_count} records updated")
            
        except Exception as e:
            logger.error(f"Close price update error: {e}")
            conn.rollback()
        finally:
            if conn:
                conn.close()

    def main():
        """Main function with continuous processing"""
        logger.info("üöÄ Starting Comprehensive Materialized Table Updater with Close Prices")
        
        # Initialize connection pool
        if not init_connection_pool():
            logger.error("Failed to initialize connection pool. Exiting.")
            return
        
        # Run initial update
        update_materialized_table()
        
        # Update close prices for completed days
        update_close_prices_for_completed_days()
        
        # Schedule regular updates
        schedule.every(5).minutes.do(update_materialized_table)
        schedule.every(10).minutes.do(continuous_sentiment_backfill)
        schedule.every(30).minutes.do(update_close_prices_for_completed_days)
        
        logger.info("‚è∞ Materialized updater scheduled: main update every 5 minutes, sentiment backfill every 10 minutes, close price update every 30 minutes")
        
        # Keep the service running
        while True:
            schedule.run_pending()
            time.sleep(30)  # Check every 30 seconds

    if __name__ == "__main__":
        main()
