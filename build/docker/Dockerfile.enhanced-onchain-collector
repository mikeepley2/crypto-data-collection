# Enhanced Onchain Collector Dockerfile
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    default-libmysqlclient-dev \
    pkg-config \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Install additional dependencies for the enhanced collector
RUN pip install --no-cache-dir \
    aiohttp \
    aiomysql \
    asyncio \
    python-dateutil

# Copy application code
COPY services/onchain-collection/ ./services/onchain-collection/
COPY shared/ ./shared/

# Create a simple health check endpoint script
RUN echo '#!/usr/bin/env python3\n\
import http.server\n\
import socketserver\n\
import json\n\
import threading\n\
import time\n\
import asyncio\n\
import sys\n\
import os\n\
\n\
# Add paths\n\
sys.path.append("/app")\n\
sys.path.append("/app/services/onchain-collection")\n\
\n\
from enhanced_onchain_collector import EnhancedOnchainCollector\n\
\n\
class HealthHandler(http.server.BaseHTTPRequestHandler):\n\
    def do_GET(self):\n\
        if self.path == "/health" or self.path == "/ready":\n\
            self.send_response(200)\n\
            self.send_header("Content-type", "application/json")\n\
            self.end_headers()\n\
            response = {"status": "healthy", "service": "onchain-collector"}\n\
            self.wfile.write(json.dumps(response).encode())\n\
        else:\n\
            self.send_response(404)\n\
            self.end_headers()\n\
\n\
def run_health_server():\n\
    PORT = 8000\n\
    with socketserver.TCPServer(("", PORT), HealthHandler) as httpd:\n\
        httpd.serve_forever()\n\
\n\
async def run_collector():\n\
    """Run the enhanced onchain collector continuously"""\n\
    collector = EnhancedOnchainCollector()\n\
    \n\
    while True:\n\
        try:\n\
            print(f"Starting onchain collection cycle at {time.strftime(\"%Y-%m-%d %H:%M:%S\")}")\n\
            await collector.run_daily_collection()\n\
            print("Collection cycle completed")\n\
            \n\
            # Wait for next collection interval (default 1 hour)\n\
            interval = int(os.getenv("COLLECTION_INTERVAL", 3600))\n\
            print(f"Waiting {interval} seconds until next collection...")\n\
            await asyncio.sleep(interval)\n\
            \n\
        except Exception as e:\n\
            print(f"Error in collection cycle: {e}")\n\
            print("Waiting 5 minutes before retry...")\n\
            await asyncio.sleep(300)  # Wait 5 minutes on error\n\
\n\
def main():\n\
    # Start health check server in background thread\n\
    health_thread = threading.Thread(target=run_health_server, daemon=True)\n\
    health_thread.start()\n\
    print("Health check server started on port 8000")\n\
    \n\
    # Run the collector\n\
    asyncio.run(run_collector())\n\
\n\
if __name__ == "__main__":\n\
    main()\n\
' > /app/collector_service.py

# Make the service script executable
RUN chmod +x /app/collector_service.py

# Expose port for health checks
EXPOSE 8000

# Set environment variables
ENV PYTHONPATH=/app:/app/services/onchain-collection:/app/shared
ENV PYTHONUNBUFFERED=1

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Run the collector service
CMD ["python3", "/app/collector_service.py"]