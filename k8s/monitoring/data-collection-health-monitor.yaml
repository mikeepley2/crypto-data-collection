---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: data-collection-health-monitor
  namespace: crypto-collectors
  labels:
    app: data-collection-health-monitor
    component: monitoring
spec:
  schedule: "*/15 * * * *" # Every 15 minutes
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: data-collection-health-monitor
            component: monitoring
        spec:
          containers:
            - name: health-monitor
              image: python:3.10-slim
              command:
                - python
                - /app/monitor_data_collection_health.py
                - --once
                - --alert-threshold
                - "2"
              env:
                - name: MYSQL_HOST
                  value: "192.168.230.162"
                - name: MYSQL_USER
                  value: "news_collector"
                - name: MYSQL_PASSWORD
                  value: "99Rules!"
                - name: MYSQL_DATABASE
                  value: "crypto_prices"
              resources:
                requests:
                  cpu: 100m
                  memory: 128Mi
                limits:
                  cpu: 200m
                  memory: 256Mi
              volumeMounts:
                - name: monitor-script
                  mountPath: /app
          volumes:
            - name: monitor-script
              configMap:
                name: data-collection-health-monitor-script
                defaultMode: 0755
          restartPolicy: OnFailure
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: data-collection-health-monitor-script
  namespace: crypto-collectors
  labels:
    app: data-collection-health-monitor
    component: monitoring
data:
  monitor_data_collection_health.py: |
    #!/usr/bin/env python3
    """
    Automated Data Collection Health Monitor
    ========================================

    This script monitors the data collection system and alerts when:
    1. ML feature processing stops or falls behind
    2. Data collection gaps exceed thresholds
    3. System health score drops below acceptable levels
    4. Services become unavailable
    """

    import argparse
    import logging
    import sys
    import time
    from datetime import datetime, timedelta
    from typing import Dict, Any, Optional
    import mysql.connector
    import requests
    import json

    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout)
        ]
    )
    logger = logging.getLogger(__name__)

    class DataCollectionHealthMonitor:
        """Monitor data collection system health and alert on issues"""
        
        def __init__(self, alert_threshold_hours: int = 2):
            self.alert_threshold_hours = alert_threshold_hours
            self.db_config = {
                'host': '192.168.230.162',
                'user': 'news_collector',
                'password': '99Rules!',
                'database': 'crypto_prices',
                'charset': 'utf8mb4'
            }
            
        def get_db_connection(self):
            """Get database connection"""
            return mysql.connector.connect(**self.db_config)
        
        def check_ml_features_health(self) -> Dict[str, Any]:
            """Check ML features materialization health"""
            try:
                conn = self.get_db_connection()
                cursor = conn.cursor(dictionary=True)
                
                # Get latest ML feature data
                cursor.execute("""
                    SELECT 
                        MAX(timestamp_iso) as latest_data,
                        COUNT(*) as total_records,
                        COUNT(DISTINCT symbol) as unique_symbols,
                        MAX(updated_at) as latest_update
                    FROM ml_features_materialized
                """)
                ml_data = cursor.fetchone()
                
                # Get recent processing activity
                cursor.execute("""
                    SELECT COUNT(*) as recent_updates
                    FROM ml_features_materialized 
                    WHERE updated_at >= %s
                """, (datetime.now() - timedelta(hours=1),))
                recent_activity = cursor.fetchone()
                
                cursor.close()
                conn.close()
                
                # Calculate health metrics
                latest_data_time = ml_data['latest_data']
                latest_update_time = ml_data['latest_update']
                data_age_hours = (datetime.now() - latest_data_time).total_seconds() / 3600 if latest_data_time else 999
                update_age_hours = (datetime.now() - latest_update_time).total_seconds() / 3600 if latest_update_time else 999
                
                health_score = 100
                issues = []
                
                # Check data freshness
                if data_age_hours > self.alert_threshold_hours:
                    health_score -= 40
                    issues.append(f"ML data is {data_age_hours:.1f} hours old (threshold: {self.alert_threshold_hours}h)")
                
                # Check processing activity
                if recent_activity['recent_updates'] == 0:
                    health_score -= 30
                    issues.append("No ML feature updates in the last hour")
                
                # Check symbol coverage
                if ml_data['unique_symbols'] < 100:
                    health_score -= 20
                    issues.append(f"Low symbol coverage: {ml_data['unique_symbols']} symbols")
                
                return {
                    'health_score': max(0, health_score),
                    'latest_data': latest_data_time,
                    'latest_update': latest_update_time,
                    'data_age_hours': data_age_hours,
                    'update_age_hours': update_age_hours,
                    'total_records': ml_data['total_records'],
                    'unique_symbols': ml_data['unique_symbols'],
                    'recent_updates': recent_activity['recent_updates'],
                    'issues': issues,
                    'status': 'healthy' if health_score >= 80 else 'warning' if health_score >= 60 else 'critical'
                }
                
            except Exception as e:
                logger.error(f"Error checking ML features health: {e}")
                return {
                    'health_score': 0,
                    'status': 'error',
                    'error': str(e)
                }
        
        def check_price_data_health(self) -> Dict[str, Any]:
            """Check price data collection health"""
            try:
                conn = self.get_db_connection()
                cursor = conn.cursor(dictionary=True)
                
                # Get latest price data
                cursor.execute("""
                    SELECT 
                        MAX(timestamp_iso) as latest_price,
                        COUNT(*) as total_records,
                        COUNT(DISTINCT symbol) as unique_symbols
                    FROM price_data_real
                    WHERE timestamp_iso >= %s
                """, (datetime.now() - timedelta(hours=24),))
                price_data = cursor.fetchone()
                
                cursor.close()
                conn.close()
                
                latest_price_time = price_data['latest_price']
                price_age_hours = (datetime.now() - latest_price_time).total_seconds() / 3600 if latest_price_time else 999
                
                health_score = 100
                issues = []
                
                # Check price data freshness
                if price_age_hours > 1:  # Price data should be very fresh
                    health_score -= 50
                    issues.append(f"Price data is {price_age_hours:.1f} hours old")
                
                # Check data volume
                if price_data['total_records'] < 1000:  # Should have many records in 24h
                    health_score -= 30
                    issues.append(f"Low price data volume: {price_data['total_records']} records in 24h")
                
                return {
                    'health_score': max(0, health_score),
                    'latest_price': latest_price_time,
                    'price_age_hours': price_age_hours,
                    'total_records': price_data['total_records'],
                    'unique_symbols': price_data['unique_symbols'],
                    'issues': issues,
                    'status': 'healthy' if health_score >= 80 else 'warning' if health_score >= 60 else 'critical'
                }
                
            except Exception as e:
                logger.error(f"Error checking price data health: {e}")
                return {
                    'health_score': 0,
                    'status': 'error',
                    'error': str(e)
                }
        
        def run_health_check(self) -> Dict[str, Any]:
            """Run complete health check"""
            logger.info("üîç Running data collection health check...")
            
            # Check all components
            ml_health = self.check_ml_features_health()
            price_health = self.check_price_data_health()
            
            # Calculate overall health
            scores = [ml_health['health_score'], price_health['health_score']]
            overall_score = sum(scores) / len(scores)
            
            all_issues = []
            all_issues.extend(ml_health.get('issues', []))
            all_issues.extend(price_health.get('issues', []))
            
            status = 'healthy'
            if overall_score < 60:
                status = 'critical'
            elif overall_score < 80:
                status = 'warning'
            
            overall_health = {
                'overall_score': overall_score,
                'status': status,
                'issues': all_issues,
                'ml_health': ml_health,
                'price_health': price_health
            }
            
            # Log results
            logger.info(f"üìä Health Check Results:")
            logger.info(f"   Overall Score: {overall_health['overall_score']:.1f}/100 ({overall_health['status']})")
            logger.info(f"   ML Features: {ml_health['health_score']}/100")
            logger.info(f"   Price Data: {price_health['health_score']}/100")
            
            if overall_health['issues']:
                logger.warning(f"‚ö†Ô∏è Issues detected: {len(overall_health['issues'])}")
                for issue in overall_health['issues']:
                    logger.warning(f"   ‚Ä¢ {issue}")
            
            # Send alert if needed
            if overall_health['status'] in ['critical', 'warning']:
                alert_message = f"""
    üö® DATA COLLECTION HEALTH ALERT üö®

    Status: {overall_health['status'].upper()}
    Overall Health Score: {overall_health['overall_score']:.1f}/100
    Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

    Issues Detected:
    {chr(10).join(f"‚Ä¢ {issue}" for issue in overall_health['issues'])}

    ML Features Health: {overall_health['ml_health']['health_score']}/100
    Price Data Health: {overall_health['price_health']['health_score']}/100

    Action Required: Please investigate and resolve the issues above.
                """
                
                logger.warning(f"ALERT: {alert_message}")
            
            return overall_health

    def main():
        parser = argparse.ArgumentParser(description='Data Collection Health Monitor')
        parser.add_argument('--alert-threshold', type=int, default=2,
                           help='Alert threshold in hours for data age (default: 2)')
        parser.add_argument('--once', action='store_true',
                           help='Run health check once and exit')
        
        args = parser.parse_args()
        
        monitor = DataCollectionHealthMonitor(
            alert_threshold_hours=args.alert_threshold
        )
        
        health_data = monitor.run_health_check()
        
        # Exit with error code if critical issues found
        if health_data['status'] == 'critical':
            sys.exit(1)
        elif health_data['status'] == 'warning':
            sys.exit(2)
        else:
            sys.exit(0)

    if __name__ == '__main__':
        main()
