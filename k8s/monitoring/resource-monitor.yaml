apiVersion: apps/v1
kind: Deployment
metadata:
  name: resource-monitor
  namespace: crypto-data-collection
  labels:
    app: resource-monitor
    component: monitoring
    node-type: analytics
spec:
  replicas: 1
  selector:
    matchLabels:
      app: resource-monitor
  template:
    metadata:
      labels:
        app: resource-monitor
        component: monitoring
        node-type: analytics
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8000"
        prometheus.io/path: "/metrics"
    spec:
      nodeSelector:
        node-type: analytics
      tolerations:
        - key: "analytics-infrastructure"
          operator: "Equal"
          value: "true"
          effect: "NoSchedule"
      containers:
        - name: resource-monitor
          image: python:3.11-slim
          ports:
            - containerPort: 8000
              name: http
          command:
            - /bin/bash
            - -c
          args:
            - |
              # Install dependencies
              pip install fastapi uvicorn prometheus-client kubernetes

              # Create application directory
              mkdir -p /app

              # Create the resource monitoring service
              cat > /app/main.py << 'EOF'
              import asyncio
              import logging
              import os
              import time
              from datetime import datetime, timedelta
              from fastapi import FastAPI
              from prometheus_client import Counter, Histogram, Gauge, generate_latest
              import uvicorn
              from kubernetes import client, config

              # Configure logging
              logging.basicConfig(level=logging.INFO)
              logger = logging.getLogger(__name__)

              # Resource metrics
              POD_CPU_REQUEST = Gauge('pod_cpu_request_cores', 'Pod CPU request in cores', ['pod', 'namespace', 'node'])
              POD_CPU_LIMIT = Gauge('pod_cpu_limit_cores', 'Pod CPU limit in cores', ['pod', 'namespace', 'node'])
              POD_MEMORY_REQUEST = Gauge('pod_memory_request_bytes', 'Pod memory request in bytes', ['pod', 'namespace', 'node'])
              POD_MEMORY_LIMIT = Gauge('pod_memory_limit_bytes', 'Pod memory limit in bytes', ['pod', 'namespace', 'node'])

              NODE_CPU_CAPACITY = Gauge('node_cpu_capacity_cores', 'Node CPU capacity in cores', ['node'])
              NODE_MEMORY_CAPACITY = Gauge('node_memory_capacity_bytes', 'Node memory capacity in bytes', ['node'])
              NODE_CPU_ALLOCATABLE = Gauge('node_cpu_allocatable_cores', 'Node CPU allocatable in cores', ['node'])
              NODE_MEMORY_ALLOCATABLE = Gauge('node_memory_allocatable_bytes', 'Node memory allocatable in bytes', ['node'])

              RESOURCE_UTILIZATION = Gauge('resource_utilization_percent', 'Resource utilization percentage', ['resource_type', 'node', 'pod'])
              RESOURCE_EFFICIENCY = Gauge('resource_efficiency_percent', 'Resource efficiency percentage', ['resource_type', 'node'])

              QUOTA_USAGE = Gauge('quota_usage_percent', 'Resource quota usage percentage', ['quota_type', 'namespace'])
              QUOTA_LIMIT = Gauge('quota_limit', 'Resource quota limit', ['quota_type', 'namespace'])

              class ResourceMonitor:
                  def __init__(self):
                      self.app = FastAPI(title="Resource Monitor Service", version="1.0.0")
                      self.setup_routes()
                      
                      # Kubernetes client
                      try:
                          config.load_incluster_config()
                          self.k8s_client = client.CoreV1Api()
                          self.k8s_apps_client = client.AppsV1Api()
                      except:
                          logger.warning("Could not load Kubernetes config")
                          self.k8s_client = None
                          self.k8s_apps_client = None
                      
                      logger.info("ðŸš€ Resource Monitor initialized")

                  def setup_routes(self):
                      @self.app.get("/health")
                      async def health():
                          return {
                              "status": "healthy",
                              "service": "resource-monitor",
                              "version": "1.0.0",
                              "k8s_client": self.k8s_client is not None
                          }

                      @self.app.get("/metrics")
                      async def metrics():
                          return generate_latest()

                      @self.app.get("/resources")
                      async def resource_summary():
                          return await self.get_resource_summary()

                  async def get_pod_resources(self):
                      """Get resource requests and limits for all pods"""
                      if not self.k8s_client:
                          return {}
                      
                      try:
                          pods = self.k8s_client.list_namespaced_pod(
                              namespace="crypto-data-collection"
                          )
                          
                          pod_resources = {}
                          for pod in pods.items:
                              if pod.status.phase == "Running":
                                  pod_name = pod.metadata.name
                                  node_name = pod.spec.node_name
                                  
                                  # Calculate total resources for pod
                                  total_cpu_request = 0
                                  total_cpu_limit = 0
                                  total_memory_request = 0
                                  total_memory_limit = 0
                                  
                                  for container in pod.spec.containers:
                                      resources = container.resources
                                      if resources:
                                          # Parse CPU requests
                                          if resources.requests and 'cpu' in resources.requests:
                                              cpu_request = resources.requests['cpu']
                                              if cpu_request.endswith('m'):
                                                  total_cpu_request += int(cpu_request[:-1]) / 1000
                                              else:
                                                  total_cpu_request += float(cpu_request)
                                          
                                          # Parse CPU limits
                                          if resources.limits and 'cpu' in resources.limits:
                                              cpu_limit = resources.limits['cpu']
                                              if cpu_limit.endswith('m'):
                                                  total_cpu_limit += int(cpu_limit[:-1]) / 1000
                                              else:
                                                  total_cpu_limit += float(cpu_limit)
                                          
                                          # Parse memory requests
                                          if resources.requests and 'memory' in resources.requests:
                                              memory_request = resources.requests['memory']
                                              if memory_request.endswith('Mi'):
                                                  total_memory_request += int(memory_request[:-2]) * 1024 * 1024
                                              elif memory_request.endswith('Gi'):
                                                  total_memory_request += float(memory_request[:-2]) * 1024 * 1024 * 1024
                                              else:
                                                  total_memory_request += int(memory_request)
                                          
                                          # Parse memory limits
                                          if resources.limits and 'memory' in resources.limits:
                                              memory_limit = resources.limits['memory']
                                              if memory_limit.endswith('Mi'):
                                                  total_memory_limit += int(memory_limit[:-2]) * 1024 * 1024
                                              elif memory_limit.endswith('Gi'):
                                                  total_memory_limit += float(memory_limit[:-2]) * 1024 * 1024 * 1024
                                              else:
                                                  total_memory_limit += int(memory_limit)
                                  
                                  pod_resources[pod_name] = {
                                      'node': node_name,
                                      'cpu_request': total_cpu_request,
                                      'cpu_limit': total_cpu_limit,
                                      'memory_request': total_memory_request,
                                      'memory_limit': total_memory_limit
                                  }
                          
                          return pod_resources
                      except Exception as e:
                          logger.error(f"Error getting pod resources: {e}")
                          return {}

                  async def get_node_resources(self):
                      """Get node resource capacity and allocatable"""
                      if not self.k8s_client:
                          return {}
                      
                      try:
                          nodes = self.k8s_client.list_node()
                          
                          node_resources = {}
                          for node in nodes.items:
                              node_name = node.metadata.name
                              
                              # Get capacity
                              capacity = node.status.capacity
                              cpu_capacity = self.parse_cpu(capacity.get('cpu', '0'))
                              memory_capacity = self.parse_memory(capacity.get('memory', '0'))
                              
                              # Get allocatable
                              allocatable = node.status.allocatable
                              cpu_allocatable = self.parse_cpu(allocatable.get('cpu', '0'))
                              memory_allocatable = self.parse_memory(allocatable.get('memory', '0'))
                              
                              node_resources[node_name] = {
                                  'cpu_capacity': cpu_capacity,
                                  'memory_capacity': memory_capacity,
                                  'cpu_allocatable': cpu_allocatable,
                                  'memory_allocatable': memory_allocatable
                              }
                          
                          return node_resources
                      except Exception as e:
                          logger.error(f"Error getting node resources: {e}")
                          return {}

                  def parse_cpu(self, cpu_str):
                      """Parse CPU string to cores (float)"""
                      if cpu_str.endswith('m'):
                          return int(cpu_str[:-1]) / 1000
                      else:
                          return float(cpu_str)

                  def parse_memory(self, memory_str):
                      """Parse memory string to bytes (int)"""
                      if memory_str.endswith('Ki'):
                          return int(memory_str[:-2]) * 1024
                      elif memory_str.endswith('Mi'):
                          return int(memory_str[:-2]) * 1024 * 1024
                      elif memory_str.endswith('Gi'):
                          return int(memory_str[:-2]) * 1024 * 1024 * 1024
                      else:
                          return int(memory_str)

                  async def get_quota_usage(self):
                      """Get resource quota usage"""
                      if not self.k8s_client:
                          return {}
                      
                      try:
                          quotas = self.k8s_client.list_namespaced_resource_quota(
                              namespace="crypto-data-collection"
                          )
                          
                          quota_usage = {}
                          for quota in quotas.items:
                              quota_name = quota.metadata.name
                              
                              for resource, quantity in quota.status.used.items():
                                  limit = quota.status.hard.get(resource, '0')
                                  
                                  quota_usage[f"{quota_name}_{resource}"] = {
                                      'used': str(quantity),
                                      'limit': str(limit)
                                  }
                          
                          return quota_usage
                      except Exception as e:
                          logger.error(f"Error getting quota usage: {e}")
                          return {}

                  async def update_resource_metrics(self):
                      """Update all resource-related metrics"""
                      try:
                          pod_resources = await self.get_pod_resources()
                          node_resources = await self.get_node_resources()
                          quota_usage = await self.get_quota_usage()
                          
                          # Update pod resource metrics
                          for pod_name, resources in pod_resources.items():
                              node = resources['node']
                              
                              POD_CPU_REQUEST.labels(pod=pod_name, namespace="crypto-data-collection", node=node).set(resources['cpu_request'])
                              POD_CPU_LIMIT.labels(pod=pod_name, namespace="crypto-data-collection", node=node).set(resources['cpu_limit'])
                              POD_MEMORY_REQUEST.labels(pod=pod_name, namespace="crypto-data-collection", node=node).set(resources['memory_request'])
                              POD_MEMORY_LIMIT.labels(pod=pod_name, namespace="crypto-data-collection", node=node).set(resources['memory_limit'])
                          
                          # Update node resource metrics
                          for node_name, resources in node_resources.items():
                              NODE_CPU_CAPACITY.labels(node=node_name).set(resources['cpu_capacity'])
                              NODE_MEMORY_CAPACITY.labels(node=node_name).set(resources['memory_capacity'])
                              NODE_CPU_ALLOCATABLE.labels(node=node_name).set(resources['cpu_allocatable'])
                              NODE_MEMORY_ALLOCATABLE.labels(node=node_name).set(resources['memory_allocatable'])
                          
                          # Update quota metrics
                          for quota_key, usage in quota_usage.items():
                              QUOTA_USAGE.labels(quota_type=quota_key, namespace="crypto-data-collection").set(float(usage['used']))
                              QUOTA_LIMIT.labels(quota_type=quota_key, namespace="crypto-data-collection").set(float(usage['limit']))
                          
                          logger.info("Updated resource metrics")
                          
                      except Exception as e:
                          logger.error(f"Error updating resource metrics: {e}")

                  async def get_resource_summary(self):
                      """Get comprehensive resource summary"""
                      pod_resources = await self.get_pod_resources()
                      node_resources = await self.get_node_resources()
                      quota_usage = await self.get_quota_usage()
                      
                      total_cpu_request = sum(r['cpu_request'] for r in pod_resources.values())
                      total_memory_request = sum(r['memory_request'] for r in pod_resources.values())
                      
                      return {
                          "pod_count": len(pod_resources),
                          "total_cpu_request": total_cpu_request,
                          "total_memory_request_gb": total_memory_request / (1024**3),
                          "node_count": len(node_resources),
                          "quota_usage": quota_usage,
                          "timestamp": datetime.now().isoformat()
                      }

                  async def start_resource_monitoring_loop(self):
                      """Start continuous resource monitoring loop"""
                      logger.info("Starting resource monitoring loop")
                      
                      while True:
                          try:
                              await self.update_resource_metrics()
                              await asyncio.sleep(60)  # Update every minute
                          except Exception as e:
                              logger.error(f"Error in resource monitoring loop: {e}")
                              await asyncio.sleep(120)  # Wait longer on error

              # Create monitor instance
              monitor = ResourceMonitor()
              app = monitor.app

              if __name__ == "__main__":
                  logger.info("ðŸš€ Starting Resource Monitor Service")
                  
                  # Start background monitoring
                  import threading
                  def start_monitoring():
                      loop = asyncio.new_event_loop()
                      asyncio.set_event_loop(loop)
                      loop.run_until_complete(monitor.start_resource_monitoring_loop())
                  
                  monitoring_thread = threading.Thread(target=start_monitoring, daemon=True)
                  monitoring_thread.start()
                  
                  # Start the service
                  uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")
              EOF

              # Start the service
              cd /app && python main.py
          resources:
            requests:
              cpu: 50m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 256Mi
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 10
            periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: resource-monitor
  namespace: crypto-data-collection
  labels:
    app: resource-monitor
    component: monitoring
spec:
  ports:
    - port: 8000
      targetPort: 8000
      protocol: TCP
      name: http
  selector:
    app: resource-monitor
  type: ClusterIP
