apiVersion: apps/v1
kind: Deployment
metadata:
  name: enhanced-ohlc-collector
  namespace: crypto-data-collection
  labels:
    app: enhanced-ohlc-collector
    component: ohlc-collection
    tier: data-collection
spec:
  replicas: 1
  selector:
    matchLabels:
      app: enhanced-ohlc-collector
  template:
    metadata:
      labels:
        app: enhanced-ohlc-collector
        component: ohlc-collection
        tier: data-collection
    spec:
      containers:
      - name: ohlc-collector
        image: python:3.11-slim
        command: ["/bin/bash"]
        args:
        - -c
        - |
          set -e
          echo "üîß Installing dependencies..."
          apt-get update && apt-get install -y gcc default-libmysqlclient-dev pkg-config curl
          pip install --no-cache-dir fastapi==0.104.1 uvicorn[standard]==0.24.0 mysql-connector-python==8.2.0 requests==2.31.0 schedule==1.2.0 prometheus-client==0.19.0 python-multipart==0.0.6 pydantic==2.5.0
          
          echo "üìÅ Creating shared directory..."
          mkdir -p /app/shared
          
          echo "üì• Creating table config..."
          cat > /app/shared/table_config.py << 'EOF'
          # Centralized table configuration
          TABLE_CONFIGS = {
              'ohlc_data': {
                  'columns': ['symbol', 'coin_id', 'timestamp_unix', 'timestamp_iso', 
                             'open_price', 'high_price', 'low_price', 'close_price', 'volume', 'data_source'],
                  'primary_key': ['symbol', 'timestamp_unix'],
                  'indexes': ['symbol', 'timestamp_iso', 'data_source']
              },
              'price_data_real': {
                  'columns': ['symbol', 'coin_id', 'name', 'current_price', 'market_cap', 'volume_24h'],
                  'primary_key': ['symbol'],
                  'indexes': ['symbol', 'coin_id']
              }
          }
          
          CRYPTO_SYMBOLS = {
              'BTC': 'bitcoin',
              'ETH': 'ethereum', 
              'XRP': 'ripple',
              'LTC': 'litecoin',
              'ADA': 'cardano',
              'DOT': 'polkadot',
              'LINK': 'chainlink',
              'BCH': 'bitcoin-cash',
              'XLM': 'stellar',
              'UNI': 'uniswap',
              'AAVE': 'aave',
              'SUSHI': 'sushi',
              'COMP': 'compound-governance-token',
              'MKR': 'maker',
              'SNX': 'synthetix-network-token'
          }
          
          def get_table_config(table_name):
              return TABLE_CONFIGS.get(table_name, {})
              
          def get_coin_id_for_symbol(symbol):
              return CRYPTO_SYMBOLS.get(symbol.upper())
          EOF
          
          echo "üì• Creating enhanced OHLC collector..."
          cat > /app/enhanced_ohlc_collector.py << 'EOF'
          import os
          import sys
          import time
          import logging
          import mysql.connector
          import requests
          import schedule
          from datetime import datetime, timedelta
          from typing import Dict, List, Any, Optional
          from fastapi import FastAPI, HTTPException, BackgroundTasks
          from fastapi.responses import JSONResponse
          import uvicorn
          
          # Add shared directory to path
          sys.path.append('/app/shared')
          from table_config import get_coin_id_for_symbol, CRYPTO_SYMBOLS
          
          # Configure logging
          logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
          logger = logging.getLogger('enhanced-ohlc-collector')
          
          class EnhancedOHLCCollector:
              def __init__(self):
                  self.service_name = "enhanced-ohlc-collector"
                  self.app = FastAPI(title="Enhanced OHLC Collector", version="1.0.0")
                  self.collection_interval = int(os.getenv('COLLECTION_INTERVAL', '3600'))
                  
                  # Database configuration
                  self.db_config = {
                      'host': os.getenv('MYSQL_HOST', 'localhost'),
                      'port': int(os.getenv('MYSQL_PORT', '3306')),
                      'user': os.getenv('MYSQL_USER', 'root'),
                      'password': os.getenv('MYSQL_PASSWORD', ''),
                      'database': os.getenv('MYSQL_DATABASE', 'crypto_data_collection'),
                      'charset': 'utf8mb4',
                      'autocommit': True
                  }
                  
                  # API configuration
                  self.api_key = os.getenv('COINGECKO_API_KEY', 'CG-94NCcVD2euxaGTZe94bS2oYz')
                  self.base_url = 'https://pro-api.coingecko.com/api/v3'
                  self.symbols = list(CRYPTO_SYMBOLS.keys())[:15]  # Limit to first 15 for K8s
                  
                  # Statistics
                  self.stats = {
                      'total_collections': 0,
                      'successful_collections': 0,
                      'failed_collections': 0,
                      'ohlc_records_collected': 0,
                      'database_writes': 0,
                      'api_calls': 0,
                      'last_collection': None,
                      'last_success': None,
                      'last_error': None,
                      'symbols_processed': 0
                  }
                  
                  # Health metrics
                  self.health_metrics = {
                      'consecutive_failures': 0,
                      'api_error_count': 0,
                      'database_error_count': 0
                  }
                  
                  self._setup_api_endpoints()
                  logger.info(f"üìä Enhanced OHLC Collector initialized")
                  logger.info(f"üìä Tracking {len(self.symbols)} symbols")
                  logger.info(f"üîë Using CoinGecko Premium API: {self.api_key[:8]}...")
          
              def make_request(self, endpoint: str, params: Dict = None) -> Optional[Dict]:
                  try:
                      headers = {'x-cg-pro-api-key': self.api_key}
                      url = f"{self.base_url}/{endpoint}"
                      
                      self.stats['api_calls'] += 1
                      response = requests.get(url, params=params, headers=headers, timeout=30)
                      
                      if response.status_code == 200:
                          return response.json()
                      else:
                          logger.warning(f"API request failed: {response.status_code}")
                          self.health_metrics['api_error_count'] += 1
                          return None
                          
                  except Exception as e:
                      logger.error(f"Request error: {e}")
                      self.health_metrics['api_error_count'] += 1
                      return None
          
              def get_current_volume(self, coin_id: str) -> Optional[float]:
                  try:
                      endpoint = f"coins/{coin_id}"
                      params = {
                          'localization': 'false',
                          'tickers': 'false', 
                          'community_data': 'false',
                          'developer_data': 'false',
                          'sparkline': 'false'
                      }
                      
                      data = self.make_request(endpoint, params)
                      
                      if data and 'market_data' in data and 'total_volume' in data['market_data']:
                          volume_usd = data['market_data']['total_volume'].get('usd', 0)
                          return float(volume_usd) if volume_usd else None
                          
                      return None
                      
                  except Exception as e:
                      logger.debug(f"Could not fetch volume for {coin_id}: {e}")
                      return None
          
              def collect_ohlc_for_symbol(self, symbol: str) -> int:
                  try:
                      coin_id = get_coin_id_for_symbol(symbol)
                      if not coin_id:
                          logger.warning(f"No coin_id found for {symbol}")
                          return 0
                      
                      endpoint = f"coins/{coin_id}/ohlc"
                      params = {'vs_currency': 'usd', 'days': 7}
                      
                      logger.debug(f"üìà Collecting OHLC data for {symbol} ({coin_id})...")
                      ohlc_data = self.make_request(endpoint, params)
                      
                      if not ohlc_data:
                          logger.warning(f"‚ö†Ô∏è No OHLC data for {symbol}")
                          return 0
                      
                      # Get current 24h volume data
                      volume = self.get_current_volume(coin_id)
                      
                      return self.store_ohlc_data(symbol, coin_id, ohlc_data, volume)
                      
                  except Exception as e:
                      logger.error(f"‚ùå Error collecting OHLC for {symbol}: {e}")
                      return 0
          
              def store_ohlc_data(self, symbol: str, coin_id: str, ohlc_data: List, volume: Optional[float] = None) -> int:
                  try:
                      conn = mysql.connector.connect(**self.db_config)
                      cursor = conn.cursor()
                      
                      insert_sql = """
                          INSERT INTO ohlc_data 
                          (symbol, coin_id, timestamp_unix, timestamp_iso, 
                           open_price, high_price, low_price, close_price, volume, data_source)
                          VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                          ON DUPLICATE KEY UPDATE
                              open_price = VALUES(open_price),
                              high_price = VALUES(high_price),
                              low_price = VALUES(low_price),
                              close_price = VALUES(close_price),
                              volume = VALUES(volume),
                              data_source = VALUES(data_source)
                      """
                      
                      records_inserted = 0
                      
                      for ohlc in ohlc_data:
                          if len(ohlc) >= 5:
                              timestamp_unix = int(ohlc[0])
                              timestamp_iso = datetime.fromtimestamp(timestamp_unix / 1000)
                              
                              # Use provided volume or try to extract from OHLC array (if available)
                              record_volume = volume
                              if record_volume is None and len(ohlc) > 5:
                                  record_volume = float(ohlc[5])
                              
                              values = (
                                  symbol,
                                  coin_id,
                                  timestamp_unix,
                                  timestamp_iso,
                                  float(ohlc[1]),  # open
                                  float(ohlc[2]),  # high
                                  float(ohlc[3]),  # low
                                  float(ohlc[4]),  # close
                                  record_volume,   # volume from parameter or OHLC array
                                  'enhanced_ohlc_collector'
                              )
                              
                              cursor.execute(insert_sql, values)
                              records_inserted += 1
                      
                      conn.commit()
                      conn.close()
                      
                      self.stats['database_writes'] += 1
                      self.stats['ohlc_records_collected'] += records_inserted
                      
                      volume_info = f" with volume ${volume:,.0f}" if volume else " (no volume data)"
                      logger.debug(f"   ‚úÖ Stored {records_inserted} OHLC records for {symbol}{volume_info}")
                      return records_inserted
                      
                  except Exception as e:
                      logger.error(f"‚ùå Error storing OHLC data for {symbol}: {e}")
                      self.health_metrics['database_error_count'] += 1
                      return 0
          
              def collect_all_ohlc_data(self) -> Dict[str, Any]:
                  start_time = datetime.now()
                  self.stats['total_collections'] += 1
                  self.stats['last_collection'] = start_time.isoformat()
                  
                  logger.info(f"üöÄ Starting OHLC collection for {len(self.symbols)} symbols...")
                  
                  successful_symbols = 0
                  failed_symbols = 0
                  total_records = 0
                  
                  for symbol in self.symbols:
                      try:
                          time.sleep(0.2)  # Rate limiting
                          records = self.collect_ohlc_for_symbol(symbol)
                          
                          if records > 0:
                              successful_symbols += 1
                              total_records += records
                              self.health_metrics['consecutive_failures'] = 0
                          else:
                              failed_symbols += 1
                              self.health_metrics['consecutive_failures'] += 1
                      except Exception as e:
                          logger.error(f"Error processing {symbol}: {e}")
                          failed_symbols += 1
                          self.health_metrics['consecutive_failures'] += 1
                  
                  duration = (datetime.now() - start_time).total_seconds()
                  self.stats['symbols_processed'] = successful_symbols
                  
                  if successful_symbols > 0:
                      self.stats['successful_collections'] += 1
                      self.stats['last_success'] = datetime.now().isoformat()
                  else:
                      self.stats['failed_collections'] += 1
                      self.stats['last_error'] = datetime.now().isoformat()
                  
                  result = {
                      'status': 'completed',
                      'duration_seconds': duration,
                      'symbols_processed': len(self.symbols),
                      'successful_symbols': successful_symbols,
                      'failed_symbols': failed_symbols,
                      'total_records_collected': total_records,
                      'timestamp': datetime.now().isoformat()
                  }
                  
                  logger.info(f"‚úÖ OHLC collection completed: {successful_symbols}/{len(self.symbols)} symbols, {total_records} records")
                  return result
          
              def calculate_health_score(self) -> int:
                  score = 100
                  
                  # Collection success rate (40 points)
                  total_collections = self.stats['total_collections']
                  if total_collections > 0:
                      success_rate = self.stats['successful_collections'] / total_collections
                      score -= int((1 - success_rate) * 40)
                  
                  # Error rates (30 points)
                  if self.health_metrics['consecutive_failures'] > 5:
                      score -= 30
                  elif self.health_metrics['consecutive_failures'] > 2:
                      score -= 15
                  
                  # API availability (20 points)
                  if self.health_metrics['api_error_count'] > 10:
                      score -= 20
                  elif self.health_metrics['api_error_count'] > 5:
                      score -= 10
                  
                  # Database health (10 points)
                  if self.health_metrics['database_error_count'] > 3:
                      score -= 10
                  elif self.health_metrics['database_error_count'] > 1:
                      score -= 5
                  
                  return max(0, min(100, score))
          
              def _setup_api_endpoints(self):
                  @self.app.get("/health")
                  def health_check():
                      health_score = self.calculate_health_score()
                      return {
                          "status": "healthy" if health_score > 70 else "degraded",
                          "health_score": health_score,
                          "service": self.service_name,
                          "symbols_tracked": len(self.symbols),
                          "timestamp": datetime.now().isoformat()
                      }
                  
                  @self.app.get("/status")
                  def get_status():
                      return {
                          "service": self.service_name,
                          "version": "1.0.0",
                          "statistics": self.stats,
                          "health_metrics": self.health_metrics,
                          "symbols": self.symbols,
                          "collection_interval": self.collection_interval,
                          "timestamp": datetime.now().isoformat()
                      }
                  
                  @self.app.post("/collect")
                  def trigger_collection():
                      result = self.collect_all_ohlc_data()
                      return result
          
              def run_service(self, host: str = "0.0.0.0", port: int = 8002):
                  logger.info(f"üöÄ Starting {self.service_name} on {host}:{port}")
                  uvicorn.run(self.app, host=host, port=port, log_level="info")
          
          def main():
              import argparse
              
              parser = argparse.ArgumentParser(description="Enhanced OHLC Collector")
              parser.add_argument("--mode", choices=["api", "scheduler"], default="api",
                                  help="Run mode: 'api' for FastAPI service, 'scheduler' for scheduled collection")
              parser.add_argument("--host", default="0.0.0.0", help="API host (api mode only)")
              parser.add_argument("--port", type=int, default=8002, help="API port (api mode only)")
              
              args = parser.parse_args()
              
              collector = EnhancedOHLCCollector()
              
              try:
                  if args.mode == "api":
                      collector.run_service(host=args.host, port=args.port)
                  else:
                      # Run initial collection then start scheduler
                      collector.collect_all_ohlc_data()
                      while True:
                          time.sleep(3600)  # Sleep for 1 hour between collections
                          collector.collect_all_ohlc_data()
              except KeyboardInterrupt:
                  logger.info("‚ö†Ô∏è Service interrupted by user")
              except Exception as e:
                  logger.error(f"‚ùå Service failed: {e}")
          
          if __name__ == "__main__":
              main()
          EOF
          
          echo "üöÄ Starting Enhanced OHLC Collector service..."
          python /app/enhanced_ohlc_collector.py --mode api --host 0.0.0.0 --port 8002
        ports:
        - containerPort: 8002
          name: http
          protocol: TCP
        env:
        - name: MYSQL_HOST
          valueFrom:
            configMapKeyRef:
              name: centralized-db-config
              key: MYSQL_HOST
        - name: MYSQL_PORT
          valueFrom:
            configMapKeyRef:
              name: centralized-db-config
              key: MYSQL_PORT
        - name: MYSQL_USER
          valueFrom:
            configMapKeyRef:
              name: centralized-db-config
              key: MYSQL_USER
        - name: MYSQL_PASSWORD
          valueFrom:
            configMapKeyRef:
              name: centralized-db-config
              key: MYSQL_PASSWORD
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: centralized-db-config
              key: MYSQL_DATABASE
        - name: COINGECKO_API_KEY
          valueFrom:
            secretKeyRef:
              name: coingecko-secret
              key: api-key
              optional: true
        - name: COLLECTION_INTERVAL
          value: "3600"
        - name: PYTHON_UNBUFFERED
          value: "1"
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8002
          initialDelaySeconds: 120
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 8002
          initialDelaySeconds: 90
          periodSeconds: 15
          timeoutSeconds: 5
          failureThreshold: 2
      tolerations:
      - key: "data-platform"
        operator: "Equal"
        value: "true"
        effect: "NoSchedule"
      restartPolicy: Always