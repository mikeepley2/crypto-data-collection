apiVersion: apps/v1
kind: Deployment
metadata:
  name: enhanced-onchain-collector
  namespace: crypto-data-collection
  labels:
    app: enhanced-onchain-collector
    tier: data-collection
    component: onchain-metrics
spec:
  replicas: 1
  selector:
    matchLabels:
      app: enhanced-onchain-collector
  template:
    metadata:
      labels:
        app: enhanced-onchain-collector
        tier: data-collection
        component: onchain-metrics
    spec:
      containers:
      - name: onchain-collector
        image: python:3.11-slim
        ports:
        - containerPort: 8004
          name: http
        resources:
          requests:
            memory: "256Mi"
            cpu: "150m"
          limits:
            memory: "512Mi"
            cpu: "300m"
        env:
        # Database configuration
        - name: MYSQL_HOST
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: host
        - name: MYSQL_USER
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: username
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: password
        - name: MYSQL_DATABASE
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: database
        
        # API Keys
        - name: COINGECKO_API_KEY
          valueFrom:
            secretKeyRef:
              name: coingecko-secret
              key: api-key
        - name: MESSARI_API_KEY
          valueFrom:
            secretKeyRef:
              name: messari-secret
              key: api-key
              optional: true
        
        # Service configuration
        - name: COLLECTION_INTERVAL
          value: "3600"  # 1 hour
        - name: PYTHONUNBUFFERED
          value: "1"
        
        # Health checks
        livenessProbe:
          httpGet:
            path: /health
            port: 8004
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /health
            port: 8004
          initialDelaySeconds: 30
          periodSeconds: 15
          timeoutSeconds: 5
          failureThreshold: 3
        
        # Install and run the collector
        command: ["/bin/bash"]
        args:
          - -c
          - |
            echo "ðŸš€ Installing Enhanced Onchain Collector v2..."
            
            # Install required packages
            apt-get update && apt-get install -y curl
            pip install --no-cache-dir \
              fastapi==0.104.1 \
              uvicorn[standard]==0.24.0 \
              aiohttp==3.9.1 \
              mysql-connector-python==8.2.0 \
              python-multipart==0.0.6
            
            echo "ðŸ“¥ Downloading onchain collector code..."
            
            # Create app directory
            mkdir -p /app
            
            # Create the onchain collector code directly
            cat > /app/enhanced_onchain_collector_v2.py << 'COLLECTOR_EOF'
            #!/usr/bin/env python3
            """
            Enhanced Onchain Data Collector v2.0
            Production-ready onchain metrics collector following OHLC template patterns
            """

            import os
            import logging
            import time
            import asyncio
            import json
            from datetime import datetime, timedelta, date
            from typing import List, Dict, Optional, Tuple
            import mysql.connector
            from mysql.connector.errors import Error as MySQLError
            import aiohttp
            from fastapi import FastAPI, HTTPException
            from fastapi.responses import JSONResponse
            import uvicorn
            import sys

            # Configure logging
            logging.basicConfig(
                level=logging.INFO,
                format="%(levelname)s:%(name)s:%(message)s",
                handlers=[logging.StreamHandler(sys.stdout)]
            )
            logger = logging.getLogger("enhanced-onchain-collector")

            class OnchainDataSource:
                def __init__(self, source_id: str, url_template: str, rate_limit: float, priority: int):
                    self.source_id = source_id
                    self.url_template = url_template
                    self.rate_limit = rate_limit
                    self.priority = priority
                    self.last_call = 0
                    self.success_count = 0
                    self.error_count = 0

            class EnhancedOnchainCollectorV2:
                def __init__(self):
                    self.app = FastAPI(title="Enhanced Onchain Collector", version="2.0.0")
                    self.setup_routes()
                    
                    # Database configuration
                    self.db_config = {
                        "host": os.getenv("MYSQL_HOST", "172.22.32.1"),
                        "user": os.getenv("MYSQL_USER", "news_collector"),
                        "password": os.getenv("MYSQL_PASSWORD", "99Rules!"),
                        "database": os.getenv("MYSQL_DATABASE", "crypto_prices"),
                        "charset": "utf8mb4",
                        "autocommit": True,
                    }
                    
                    # API configurations
                    self.coingecko_api_key = os.getenv('COINGECKO_API_KEY', 'CG-94NCcVD2euxaGTZe94bS2oYz')
                    
                    # Statistics and health tracking
                    self.statistics = {
                        'total_collections': 0, 'successful_collections': 0, 'failed_collections': 0,
                        'records_collected': 0, 'api_calls_made': 0, 'last_collection': None,
                        'last_success': None, 'last_error': None, 'database_writes': 0,
                        'symbols_processed': 0
                    }
                    
                    self.health_metrics = {
                        'consecutive_failures': 0, 'api_error_count': 0, 'database_error_count': 0,
                        'last_health_check': datetime.now()
                    }
                    
                    self.supported_symbols = ['BTC', 'ETH', 'ADA', 'SOL', 'AVAX', 'DOT', 'MATIC', 'LINK']
                    self.collection_interval = int(os.getenv("COLLECTION_INTERVAL", "3600"))
                    
                    logger.info("ðŸš€ Enhanced Onchain Collector v2.0 initialized")

                def setup_routes(self):
                    @self.app.get("/health")
                    async def health_check():
                        health_score = self.calculate_health_score()
                        self.health_metrics['last_health_check'] = datetime.now()
                        status = "healthy" if health_score >= 80 else "degraded" if health_score >= 60 else "unhealthy"
                        
                        return JSONResponse({
                            "status": status,
                            "health_score": health_score,
                            "timestamp": datetime.now().isoformat(),
                            "data_freshness": self.get_data_freshness()
                        })
                    
                    @self.app.get("/status")
                    async def get_status():
                        gap_days = self.get_data_gap_days()
                        logger.info(f"ðŸ“Š Gap analysis: {gap_days} days since last data")
                        
                        return {
                            "service": "enhanced-onchain-collector",
                            "version": "2.0.0",
                            "statistics": self.statistics.copy(),
                            "health_metrics": self.health_metrics.copy(),
                            "symbols": {"total": len(self.supported_symbols), "active": len(self.supported_symbols)},
                            "data_freshness": {"gap_days": gap_days, "status": "healthy" if gap_days <= 2 else "stale"},
                            "health_score": self.calculate_health_score(),
                            "collection_interval": self.collection_interval,
                            "timestamp": datetime.now().isoformat()
                        }
                    
                    @self.app.post("/collect")
                    async def manual_collection():
                        try:
                            logger.info("ðŸ“¡ Manual collection triggered")
                            result = await self.collect_all_symbols()
                            return {"status": "completed", "result": result, "timestamp": datetime.now().isoformat()}
                        except Exception as e:
                            logger.error(f"Manual collection failed: {e}")
                            raise HTTPException(status_code=500, detail=f"Collection failed: {str(e)}")

                def calculate_health_score(self) -> float:
                    score = 100.0
                    consecutive_failures = self.health_metrics['consecutive_failures']
                    if consecutive_failures > 0:
                        score -= min(consecutive_failures * 10, 40)
                    
                    db_error_count = self.health_metrics['database_error_count']
                    if db_error_count > 0:
                        score -= min(db_error_count, 30)
                    
                    gap_days = self.get_data_gap_days()
                    if gap_days <= 1:
                        pass
                    elif gap_days <= 3:
                        score -= 10
                    else:
                        score -= 20
                    
                    return max(0.0, min(100.0, score))

                def get_data_gap_days(self) -> int:
                    try:
                        conn = mysql.connector.connect(**self.db_config)
                        cursor = conn.cursor()
                        cursor.execute("SELECT MAX(DATE(timestamp_iso)) FROM onchain_data WHERE data_source LIKE '%enhanced-onchain-collector%'")
                        result = cursor.fetchone()
                        cursor.close()
                        conn.close()
                        
                        if result[0]:
                            return (date.today() - result[0]).days
                    except Exception as e:
                        logger.warning(f"Error calculating data gap: {e}")
                    return 999

                def get_data_freshness(self) -> Dict:
                    gap_days = self.get_data_gap_days()
                    status = "fresh" if gap_days <= 1 else "acceptable" if gap_days <= 3 else "stale"
                    return {"gap_days": gap_days, "status": status, "last_update": self.statistics.get('last_success')}

                def get_db_connection(self):
                    try:
                        return mysql.connector.connect(**self.db_config)
                    except MySQLError as e:
                        self.health_metrics['database_error_count'] += 1
                        logger.error(f"Database connection error: {e}")
                        raise

                def ensure_onchain_table(self):
                    try:
                        conn = self.get_db_connection()
                        cursor = conn.cursor()
                        
                        create_table_sql = \"\"\"
                            CREATE TABLE IF NOT EXISTS onchain_data (
                                id BIGINT AUTO_INCREMENT PRIMARY KEY,
                                symbol VARCHAR(100) NOT NULL,
                                coin_id VARCHAR(150),
                                timestamp_iso DATETIME(6) NOT NULL,
                                
                                -- Core metrics
                                active_addresses BIGINT,
                                transaction_count BIGINT,
                                transaction_volume DECIMAL(25,8),
                                market_cap_rank INT,
                                circulating_supply DECIMAL(25,8),
                                total_supply DECIMAL(25,8),
                                max_supply DECIMAL(25,8),
                                
                                -- Price metrics
                                price_change_percentage_24h DECIMAL(10,4),
                                price_change_percentage_7d DECIMAL(10,4),
                                total_volume DECIMAL(25,2),
                                
                                -- Development metrics
                                github_commits_30d INT,
                                developer_activity_score DECIMAL(10,4),
                                
                                -- Data quality
                                data_source VARCHAR(200),
                                data_quality_score DECIMAL(3,2) DEFAULT 1.0,
                                collected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                                
                                UNIQUE KEY unique_symbol_timestamp (symbol, timestamp_iso),
                                INDEX idx_symbol (symbol),
                                INDEX idx_timestamp (timestamp_iso)
                            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
                        \"\"\"
                        
                        cursor.execute(create_table_sql)
                        conn.commit()
                        cursor.close()
                        conn.close()
                        logger.info("âœ… onchain_data table verified")
                        
                    except Exception as e:
                        logger.error(f"Error ensuring onchain_data table: {e}")
                        self.health_metrics['database_error_count'] += 1

                async def fetch_coingecko_data(self, session, symbol: str) -> Optional[Dict]:
                    try:
                        await asyncio.sleep(1.0)  # Rate limiting
                        self.statistics['api_calls_made'] += 1
                        
                        coin_id = {'BTC': 'bitcoin', 'ETH': 'ethereum', 'ADA': 'cardano', 'SOL': 'solana', 
                                  'AVAX': 'avalanche-2', 'DOT': 'polkadot', 'MATIC': 'polygon', 'LINK': 'chainlink'}.get(symbol, symbol.lower())
                        
                        base_url = "https://api.coingecko.com/api/v3"
                        if self.coingecko_api_key.startswith('CG-'):
                            base_url = "https://pro-api.coingecko.com/api/v3"
                        
                        url = f"{base_url}/coins/{coin_id}"
                        headers = {'x-cg-pro-api-key': self.coingecko_api_key} if self.coingecko_api_key.startswith('CG-') else {}
                        params = {'localization': 'false', 'tickers': 'false', 'market_data': 'true', 'developer_data': 'true'}
                        
                        async with session.get(url, headers=headers, params=params, timeout=30) as response:
                            if response.status == 200:
                                data = await response.json()
                                return self.parse_coingecko_data(data, symbol)
                            else:
                                logger.warning(f"CoinGecko API error for {symbol}: {response.status}")
                                self.health_metrics['api_error_count'] += 1
                                return None
                    except Exception as e:
                        logger.error(f"Error fetching CoinGecko data for {symbol}: {e}")
                        self.health_metrics['api_error_count'] += 1
                        return None

                def parse_coingecko_data(self, data: Dict, symbol: str) -> Dict:
                    try:
                        market_data = data.get('market_data', {})
                        developer_data = data.get('developer_data', {})
                        
                        market_cap_usd = market_data.get('market_cap', {}).get('usd')
                        total_volume_usd = market_data.get('total_volume', {}).get('usd')
                        
                        return {
                            'symbol': symbol,
                            'coin_id': data.get('id'),
                            'timestamp_iso': datetime.now(),
                            'market_cap_rank': market_data.get('market_cap_rank'),
                            'circulating_supply': market_data.get('circulating_supply'),
                            'total_supply': market_data.get('total_supply'),
                            'max_supply': market_data.get('max_supply'),
                            'price_change_percentage_24h': market_data.get('price_change_percentage_24h'),
                            'price_change_percentage_7d': market_data.get('price_change_percentage_7d'),
                            'total_volume': total_volume_usd,
                            'github_commits_30d': developer_data.get('commit_count_4_weeks'),
                            'developer_activity_score': min(developer_data.get('commit_count_4_weeks', 0) / 100.0, 1.0) if developer_data.get('commit_count_4_weeks') else None,
                            'data_source': 'enhanced-onchain-collector-v2-coingecko',
                            'data_quality_score': 0.95 if self.coingecko_api_key.startswith('CG-') else 0.85
                        }
                    except Exception as e:
                        logger.error(f"Error parsing CoinGecko data for {symbol}: {e}")
                        return None

                async def collect_symbol_data(self, symbol: str) -> Optional[Dict]:
                    try:
                        async with aiohttp.ClientSession() as session:
                            data = await self.fetch_coingecko_data(session, symbol)
                            return data
                    except Exception as e:
                        logger.error(f"Error collecting data for {symbol}: {e}")
                        return None

                def store_onchain_data(self, data_records: List[Dict]) -> int:
                    if not data_records:
                        return 0
                    
                    try:
                        conn = self.get_db_connection()
                        cursor = conn.cursor()
                        
                        insert_query = \"\"\"
                            INSERT INTO onchain_data (
                                symbol, coin_id, timestamp_iso, market_cap_rank, circulating_supply, 
                                total_supply, max_supply, price_change_percentage_24h, price_change_percentage_7d,
                                total_volume, github_commits_30d, developer_activity_score,
                                data_source, data_quality_score
                            ) VALUES (
                                %(symbol)s, %(coin_id)s, %(timestamp_iso)s, %(market_cap_rank)s, %(circulating_supply)s,
                                %(total_supply)s, %(max_supply)s, %(price_change_percentage_24h)s, %(price_change_percentage_7d)s,
                                %(total_volume)s, %(github_commits_30d)s, %(developer_activity_score)s,
                                %(data_source)s, %(data_quality_score)s
                            ) ON DUPLICATE KEY UPDATE
                                market_cap_rank = VALUES(market_cap_rank),
                                circulating_supply = VALUES(circulating_supply),
                                total_supply = VALUES(total_supply),
                                max_supply = VALUES(max_supply),
                                price_change_percentage_24h = VALUES(price_change_percentage_24h),
                                price_change_percentage_7d = VALUES(price_change_percentage_7d),
                                total_volume = VALUES(total_volume),
                                github_commits_30d = VALUES(github_commits_30d),
                                developer_activity_score = VALUES(developer_activity_score),
                                data_source = VALUES(data_source),
                                data_quality_score = VALUES(data_quality_score),
                                updated_at = CURRENT_TIMESTAMP
                        \"\"\"
                        
                        cursor.executemany(insert_query, data_records)
                        rows_affected = cursor.rowcount
                        conn.commit()
                        
                        self.statistics['database_writes'] += rows_affected
                        cursor.close()
                        conn.close()
                        
                        logger.info(f"âœ… Stored {rows_affected} onchain records")
                        return rows_affected
                        
                    except Exception as e:
                        logger.error(f"Error storing onchain data: {e}")
                        self.health_metrics['database_error_count'] += 1
                        return 0

                async def collect_all_symbols(self) -> Dict:
                    logger.info("ðŸš€ Starting onchain data collection")
                    self.statistics['total_collections'] += 1
                    
                    self.ensure_onchain_table()
                    
                    collected_data = []
                    failed_symbols = []
                    
                    for symbol in self.supported_symbols:
                        try:
                            data = await self.collect_symbol_data(symbol)
                            if data:
                                collected_data.append(data)
                                logger.info(f"âœ… Collected data for {symbol}")
                            else:
                                failed_symbols.append(symbol)
                                logger.warning(f"âŒ Failed to collect data for {symbol}")
                            
                            await asyncio.sleep(1.0)
                        except Exception as e:
                            logger.error(f"Error processing {symbol}: {e}")
                            failed_symbols.append(symbol)
                    
                    stored_count = 0
                    if collected_data:
                        stored_count = self.store_onchain_data(collected_data)
                        self.statistics['records_collected'] += stored_count
                        self.statistics['symbols_processed'] = len(self.supported_symbols)
                        
                        if len(failed_symbols) == 0:
                            self.statistics['successful_collections'] += 1
                            self.statistics['last_success'] = datetime.now().isoformat()
                            self.health_metrics['consecutive_failures'] = 0
                        else:
                            self.statistics['failed_collections'] += 1
                            self.statistics['last_error'] = f"Failed symbols: {len(failed_symbols)}"
                            self.health_metrics['consecutive_failures'] += 1
                    else:
                        self.statistics['failed_collections'] += 1
                        self.statistics['last_error'] = "No data collected"
                        self.health_metrics['consecutive_failures'] += 1
                    
                    result = {
                        'symbols_processed': len(self.supported_symbols),
                        'data_collected': len(collected_data),
                        'failed_symbols': failed_symbols,
                        'records_stored': stored_count
                    }
                    
                    logger.info(f"ðŸ“Š Collection completed: {result}")
                    return result

                async def run_service(self):
                    logger.info("ðŸš€ Starting Enhanced Onchain Collector v2 service")
                    self.ensure_onchain_table()
                    
                    while True:
                        try:
                            await self.collect_all_symbols()
                            logger.info(f"â° Waiting {self.collection_interval} seconds until next collection")
                            await asyncio.sleep(self.collection_interval)
                        except Exception as e:
                            logger.error(f"Service error: {e}")
                            self.health_metrics['consecutive_failures'] += 1
                            await asyncio.sleep(60)

            def create_app() -> FastAPI:
                collector = EnhancedOnchainCollectorV2()
                return collector.app

            if __name__ == "__main__":
                collector = EnhancedOnchainCollectorV2()
                
                async def run_server():
                    config = uvicorn.Config(
                        "enhanced_onchain_collector_v2:create_app",
                        host="0.0.0.0",
                        port=8004,
                        factory=True,
                        log_level="info"
                    )
                    server = uvicorn.Server(config)
                    collection_task = asyncio.create_task(collector.run_service())
                    await server.serve()
                
                asyncio.run(run_server())
            COLLECTOR_EOF
            
            echo "ðŸš€ Starting Enhanced Onchain Collector v2..."
            cd /app
            exec python enhanced_onchain_collector_v2.py

      # Node selection for stable deployment
      nodeSelector:
        solution-area: data-platform
      
      tolerations:
      - key: "data-platform"
        operator: "Equal"
        value: "true"
        effect: "NoSchedule"
      
      restartPolicy: Always

---
apiVersion: v1
kind: Service
metadata:
  name: onchain-service
  namespace: crypto-data-collection
  labels:
    app: enhanced-onchain-collector
spec:
  type: ClusterIP
  ports:
  - port: 8004
    targetPort: 8004
    protocol: TCP
    name: http
  selector:
    app: enhanced-onchain-collector