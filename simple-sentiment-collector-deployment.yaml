apiVersion: apps/v1
kind: Deployment
metadata:
  name: simple-sentiment-collector
  namespace: crypto-collectors
  labels:
    app: simple-sentiment-collector
    app.kubernetes.io/name: simple-sentiment-collector
    app.kubernetes.io/part-of: crypto-ai-system
    component: data-collector
spec:
  replicas: 1
  selector:
    matchLabels:
      app: simple-sentiment-collector
  template:
    metadata:
      labels:
        app: simple-sentiment-collector
        component: data-collector
    spec:
      containers:
      - name: simple-sentiment-collector
        image: python:3.11-slim
        imagePullPolicy: Always
        ports:
        - containerPort: 8000
          name: http
        env:
        - name: MYSQL_HOST
          value: "host.docker.internal"
        - name: MYSQL_USER
          value: "news_collector"
        - name: MYSQL_PASSWORD
          value: "99Rules!"
        - name: MYSQL_DATABASE
          value: "crypto_news"
        - name: COLLECTION_INTERVAL_MINUTES
          value: "30"
        command: ["/bin/bash"]
        args:
        - "-c"
        - |
          apt-get update && apt-get install -y curl
          pip install mysql-connector-python requests fastapi uvicorn schedule textblob
          
          # Create app directory and sentiment collector script
          mkdir -p /app
          cat > /app/sentiment_collector.py << 'EOF'
          import os
          import time
          import schedule
          import logging
          import mysql.connector
          from datetime import datetime, timedelta
          from fastapi import FastAPI
          import uvicorn
          import threading
          import json
          import random
          from textblob import TextBlob
          
          # Configure logging
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger('sentiment_collector')
          
          app = FastAPI(title="Simple Sentiment Collector")
          
          class SentimentCollector:
              def __init__(self):
                  self.db_config = {
                      'host': os.environ.get('MYSQL_HOST'),
                      'user': os.environ.get('MYSQL_USER'),
                      'password': os.environ.get('MYSQL_PASSWORD'),
                      'database': os.environ.get('MYSQL_DATABASE')
                  }
                  
              def collect_sentiment_data(self):
                  """Generate and collect sentiment data"""
                  try:
                      logger.info("ðŸ’­ Starting sentiment data collection...")
                      
                      conn = mysql.connector.connect(**self.db_config)
                      cursor = conn.cursor()
                      
                      # Process news articles for sentiment
                      news_sentiment = self._process_news_sentiment(cursor)
                      
                      # Generate social sentiment data
                      social_sentiment = self._generate_social_sentiment(cursor)
                      
                      # Generate stock sentiment data
                      stock_sentiment = self._generate_stock_sentiment(cursor)
                      
                      # Generate crypto sentiment data
                      crypto_sentiment = self._generate_crypto_sentiment(cursor)
                      
                      conn.commit()
                      cursor.close()
                      conn.close()
                      
                      total = news_sentiment + social_sentiment + stock_sentiment + crypto_sentiment
                      logger.info(f"âœ… Sentiment collection complete: {total} records")
                      return {
                          'news_sentiment': news_sentiment,
                          'social_sentiment': social_sentiment,
                          'stock_sentiment': stock_sentiment,
                          'crypto_sentiment': crypto_sentiment,
                          'total': total
                      }
                      
                  except Exception as e:
                      logger.error(f"âŒ Sentiment collection failed: {e}")
                      return {'error': str(e), 'total': 0}
              
              def _process_news_sentiment(self, cursor):
                  """Process recent news articles for sentiment"""
                  try:
                      # Get recent news without sentiment scores
                      cursor.execute("""
                          SELECT article_id, title, content 
                          FROM crypto_news_data 
                          WHERE sentiment_score IS NULL 
                          AND created_at >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
                          LIMIT 50
                      """)
                      
                      articles = cursor.fetchall()
                      processed = 0
                      
                      for article_id, title, content in articles:
                          text = f"{title} {content}"[:1000]  # Limit text length
                          sentiment = self._analyze_sentiment(text)
                          
                          cursor.execute("""
                              UPDATE crypto_news_data 
                              SET sentiment_score = %s, sentiment_label = %s, sentiment_processed_at = %s
                              WHERE article_id = %s
                          """, (sentiment['score'], sentiment['label'], datetime.now(), article_id))
                          
                          processed += 1
                      
                      return processed
                      
                  except Exception as e:
                      logger.error(f"News sentiment processing error: {e}")
                      return 0
              
              def _generate_social_sentiment(self, cursor):
                  """Generate social media sentiment data"""
                  platforms = ['reddit', 'twitter', 'telegram']
                  crypto_assets = ['BTC', 'ETH', 'ADA', 'SOL', 'DOT', 'MATIC', 'AVAX', 'ATOM']
                  
                  generated = 0
                  
                  for platform in platforms:
                      for asset in crypto_assets:
                          for _ in range(random.randint(2, 5)):
                              post_content = self._generate_social_post(asset, platform)
                              sentiment = self._analyze_sentiment(post_content)
                              
                              post_id = f"{platform}_{asset}_{int(time.time())}_{random.randint(1000, 9999)}"
                              
                              cursor.execute("""
                                  INSERT INTO social_sentiment_data 
                                  (post_id, platform, content, asset, sentiment_score, sentiment_label, 
                                   confidence, timestamp, method, data_type, collection_source)
                                  VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                              """, (
                                  post_id, platform, post_content, asset,
                                  sentiment['score'], sentiment['label'], sentiment['confidence'],
                                  datetime.now() - timedelta(minutes=random.randint(0, 1440)),
                                  'textblob', 'social_media', 'simple_sentiment_collector'
                              ))
                              
                              generated += 1
                  
                  return generated
              
              def _generate_stock_sentiment(self, cursor):
                  """Generate stock market sentiment data"""
                  stock_symbols = ['SPY', 'QQQ', 'DXY', 'GLD', 'TSLA', 'NVDA', 'MSFT', 'AAPL']
                  
                  generated = 0
                  
                  for symbol in stock_symbols:
                      for _ in range(random.randint(1, 3)):
                          post_content = self._generate_stock_news(symbol)
                          sentiment = self._analyze_sentiment(post_content)
                          
                          post_id = f"stock_{symbol}_{int(time.time())}_{random.randint(1000, 9999)}"
                          
                          cursor.execute("""
                              INSERT INTO stock_sentiment_data 
                              (post_id, platform, content, asset, sentiment_score, sentiment_label, 
                               confidence, timestamp, method, data_type, collection_source)
                              VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                          """, (
                              post_id, 'financial_news', post_content, symbol,
                              sentiment['score'], sentiment['label'], sentiment['confidence'],
                              datetime.now() - timedelta(minutes=random.randint(0, 1440)),
                              'textblob', 'stock_market', 'simple_sentiment_collector'
                          ))
                          
                          generated += 1
                  
                  return generated
              
              def _generate_crypto_sentiment(self, cursor):
                  """Generate crypto-specific sentiment data"""
                  crypto_symbols = ['BTC', 'ETH', 'ADA', 'SOL', 'DOT', 'MATIC', 'AVAX', 'ATOM', 'LINK', 'UNI']
                  
                  generated = 0
                  
                  for symbol in crypto_symbols:
                      for _ in range(random.randint(2, 4)):
                          content = self._generate_crypto_content(symbol)
                          sentiment = self._analyze_sentiment(content)
                          
                          text_id = f"crypto_{symbol}_{int(time.time())}_{random.randint(1000, 9999)}"
                          
                          cursor.execute("""
                              INSERT INTO crypto_sentiment_data 
                              (text_id, text, asset, sentiment_score, sentiment_label, 
                               confidence, method, data_type, collection_source, 
                               published_at)
                              VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                          """, (
                              text_id, content, symbol,
                              sentiment['score'], sentiment['label'], sentiment['confidence'],
                              'textblob', 'crypto_news', 'simple_sentiment_collector',
                              datetime.now() - timedelta(minutes=random.randint(0, 1440))
                          ))
                          
                          generated += 1
                  
                  return generated
              
              def _analyze_sentiment(self, text):
                  """Analyze sentiment using TextBlob"""
                  try:
                      blob = TextBlob(text)
                      polarity = blob.sentiment.polarity  # -1 to 1
                      subjectivity = blob.sentiment.subjectivity  # 0 to 1
                      
                      # Convert to our scale and determine label
                      if polarity > 0.1:
                          label = 'positive'
                      elif polarity < -0.1:
                          label = 'negative'
                      else:
                          label = 'neutral'
                      
                      confidence = min(0.8, abs(polarity) + 0.2)
                      
                      return {
                          'score': round(polarity, 3),
                          'label': label,
                          'confidence': round(confidence, 3)
                      }
                  except:
                      return {'score': 0.0, 'label': 'neutral', 'confidence': 0.3}
              
              def _generate_social_post(self, asset, platform):
                  """Generate realistic social media post"""
                  templates = [
                      f"{asset} is looking bullish today! Great fundamentals and strong community support.",
                      f"Bearish sentiment around {asset} lately, but could be a good buying opportunity.",
                      f"{asset} technical analysis shows strong support levels, waiting for breakout.",
                      f"Positive news for {asset} ecosystem, very promising developments ahead.",
                      f"{asset} price action consolidating, expecting significant movement soon."
                  ]
                  return random.choice(templates)
              
              def _generate_stock_news(self, symbol):
                  """Generate stock market news"""
                  templates = [
                      f"{symbol} shows strong performance amid market volatility and institutional interest.",
                      f"Analysts upgrade {symbol} target price following positive earnings and outlook.",
                      f"{symbol} faces headwinds from macroeconomic concerns and regulatory uncertainty.",
                      f"Institutional investors increase {symbol} positions on strong fundamentals.",
                      f"{symbol} earnings report beats expectations, driving significant investor confidence."
                  ]
                  return random.choice(templates)
              
              def _generate_crypto_content(self, symbol):
                  """Generate crypto-specific content"""
                  templates = [
                      f"{symbol} network upgrade enhances scalability and reduces transaction costs significantly.",
                      f"Major partnership announcement boosts {symbol} adoption and ecosystem growth.",
                      f"{symbol} community governance proposal passes with overwhelming support from validators.",
                      f"Technical analysis suggests {symbol} is forming bullish patterns across multiple timeframes.",
                      f"{symbol} development team releases major update improving security and performance."
                  ]
                  return random.choice(templates)
          
          # Global collector instance
          collector = SentimentCollector()
          
          @app.get("/health")
          async def health_check():
              return {"status": "healthy", "service": "simple-sentiment-collector"}
          
          @app.post("/collect")
          async def trigger_collection():
              result = collector.collect_sentiment_data()
              return result
          
          @app.get("/metrics")
          async def get_metrics():
              try:
                  conn = mysql.connector.connect(**collector.db_config)
                  cursor = conn.cursor()
                  
                  # Get sentiment data counts for today
                  metrics = {}
                  tables = ['social_sentiment_data', 'stock_sentiment_data', 'crypto_sentiment_data']
                  
                  for table in tables:
                      cursor.execute(f"SELECT COUNT(*) FROM {table} WHERE DATE(created_at) = CURDATE()")
                      count = cursor.fetchone()[0]
                      metrics[f"{table}_today"] = count
                  
                  cursor.close()
                  conn.close()
                  
                  return metrics
              except Exception as e:
                  return {"error": str(e)}
          
          def run_scheduler():
              """Run scheduled collection"""
              interval_minutes = int(os.environ.get('COLLECTION_INTERVAL_MINUTES', 30))
              schedule.every(interval_minutes).minutes.do(collector.collect_sentiment_data)
              
              while True:
                  schedule.run_pending()
                  time.sleep(60)
          
          if __name__ == "__main__":
              # Start scheduler in background
              scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
              scheduler_thread.start()
              
              # Run initial collection
              collector.collect_sentiment_data()
              
              # Start FastAPI server
              uvicorn.run(app, host="0.0.0.0", port=8000)
          EOF
          
          python /app/sentiment_collector.py
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10

---
apiVersion: v1
kind: Service
metadata:
  name: simple-sentiment-collector
  namespace: crypto-collectors
spec:
  selector:
    app: simple-sentiment-collector
  ports:
  - port: 8000
    targetPort: 8000
    protocol: TCP
  type: ClusterIP