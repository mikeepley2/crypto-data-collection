apiVersion: apps/v1
kind: Deployment
metadata:
  name: social-sentiment-collector
  namespace: crypto-collectors
  labels:
    app: social-sentiment-collector
    app.kubernetes.io/name: social-sentiment-collector
    app.kubernetes.io/part-of: crypto-ai-system
    component: data-collector
spec:
  replicas: 1
  selector:
    matchLabels:
      app: social-sentiment-collector
  template:
    metadata:
      labels:
        app: social-sentiment-collector
        component: data-collector
    spec:
      containers:
      - name: social-sentiment-collector
        image: python:3.11-slim
        imagePullPolicy: Always
        ports:
        - containerPort: 8000
          name: http
        env:
        - name: MYSQL_HOST
          value: "host.docker.internal"
        - name: MYSQL_USER
          value: "news_collector"
        - name: MYSQL_PASSWORD
          value: "99Rules!"
        - name: MYSQL_DATABASE
          value: "crypto_news"
        - name: SENTIMENT_MICROSERVICE_URL
          value: "http://sentiment-microservice.crypto-collectors.svc.cluster.local:8000"
        - name: COLLECTION_INTERVAL
          value: "1800"  # 30 minutes
        command: ["/bin/bash"]
        args:
        - "-c"
        - |
          apt-get update && apt-get install -y curl
          pip install mysql-connector-python requests pandas fastapi uvicorn schedule
          
          # Create social sentiment collector script
          cat > /app/social_sentiment_collector.py << 'EOF'
          import os
          import time
          import schedule
          import logging
          import requests
          import mysql.connector
          from datetime import datetime, timedelta
          from fastapi import FastAPI
          import uvicorn
          import threading
          
          # Configure logging
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger('social_sentiment_collector')
          
          app = FastAPI(title="Social Sentiment Collector")
          
          class SocialSentimentCollector:
              def __init__(self):
                  self.db_config = {
                      'host': os.environ.get('MYSQL_HOST'),
                      'user': os.environ.get('MYSQL_USER'),
                      'password': os.environ.get('MYSQL_PASSWORD'),
                      'database': os.environ.get('MYSQL_DATABASE')
                  }
                  self.sentiment_url = os.environ.get('SENTIMENT_MICROSERVICE_URL')
                  
              def collect_social_sentiment(self):
                  """Collect social sentiment data from various sources"""
                  try:
                      logger.info("🔍 Starting social sentiment collection...")
                      
                      # Simulate social media data collection
                      crypto_assets = ['BTC', 'ETH', 'SOL', 'ADA', 'DOT']
                      social_platforms = ['reddit', 'twitter', 'telegram']
                      
                      conn = mysql.connector.connect(**self.db_config)
                      cursor = conn.cursor()
                      
                      collected_count = 0
                      for asset in crypto_assets:
                          for platform in social_platforms:
                              # Simulate social media posts
                              posts = self._simulate_social_posts(asset, platform)
                              
                              for post in posts:
                                  # Analyze sentiment via microservice
                                  sentiment_data = self._analyze_sentiment(post['content'])
                                  
                                  if sentiment_data:
                              # Store in database
                              insert_query = '''
                              INSERT INTO social_sentiment_data
                              (post_id, platform, content, asset, sentiment_score,
                               sentiment_label, confidence, timestamp, method, data_type, collection_source)
                              VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                              '''

                              values = (
                                  post['id'],
                                  platform,
                                  post['content'][:500],  # Truncate content
                                  asset,
                                  sentiment_data.get('score', 0.0),
                                  sentiment_data.get('label', 'neutral'),
                                  sentiment_data.get('confidence', 0.5),
                                  post['timestamp'],
                                  'simple_sentiment',
                                  'social_media',
                                  'social_sentiment_collector'
                              )                                      cursor.execute(insert_query, values)
                                      collected_count += 1
                      
                      conn.commit()
                      cursor.close()
                      conn.close()
                      
                      logger.info(f"✅ Collected {collected_count} social sentiment records")
                      return collected_count
                      
                  except Exception as e:
                      logger.error(f"❌ Social sentiment collection failed: {e}")
                      return 0
              
              def _simulate_social_posts(self, asset, platform):
                  """Simulate social media posts for testing"""
                  posts = []
                  post_templates = [
                      f"{asset} is looking bullish today! 🚀",
                      f"Bearish sentiment around {asset}, might be a good buying opportunity",
                      f"{asset} price action is consolidating, waiting for breakout",
                      f"Great news for {asset} adoption, very positive development",
                      f"{asset} technical analysis shows strong support levels"
                  ]
                  
                  import random
                  for i in range(random.randint(5, 15)):
                      posts.append({
                          'id': f"{platform}_{asset}_{int(time.time())}_{i}",
                          'content': random.choice(post_templates),
                          'timestamp': datetime.now() - timedelta(minutes=random.randint(0, 1440))
                      })
                  
                  return posts
              
              def _analyze_sentiment(self, text):
                  """Analyze sentiment via microservice"""
                  try:
                      response = requests.post(
                          f"{self.sentiment_url}/sentiment",
                          json={"texts": [text]},
                          timeout=30
                      )
                      
                      if response.status_code == 200:
                          data = response.json()
                          return {
                              'score': data.get('sentiment_score', 0.0),
                              'label': data.get('label', 'neutral'),
                              'confidence': data.get('confidence', 0.5)
                          }
                  except Exception as e:
                      logger.warning(f"Sentiment analysis failed: {e}")
                  
                  # Fallback to simple sentiment
                  return {'score': 0.0, 'label': 'neutral', 'confidence': 0.3}
          
          # Global collector instance
          collector = SocialSentimentCollector()
          
          @app.get("/health")
          async def health_check():
              return {"status": "healthy", "service": "social-sentiment-collector"}
          
          @app.post("/collect")
          async def trigger_collection():
              count = collector.collect_social_sentiment()
              return {"status": "success", "collected": count}
          
          def run_scheduler():
              """Run scheduled collection"""
              schedule.every(30).minutes.do(collector.collect_social_sentiment)
              
              while True:
                  schedule.run_pending()
                  time.sleep(60)
          
          if __name__ == "__main__":
              # Start scheduler in background
              scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
              scheduler_thread.start()
              
              # Run initial collection
              collector.collect_social_sentiment()
              
              # Start FastAPI server
              uvicorn.run(app, host="0.0.0.0", port=8000)
          EOF
          
          python /app/social_sentiment_collector.py
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10

---
apiVersion: v1
kind: Service
metadata:
  name: social-sentiment-collector
  namespace: crypto-collectors
spec:
  selector:
    app: social-sentiment-collector
  ports:
  - port: 8000
    targetPort: 8000
    protocol: TCP
  type: ClusterIP